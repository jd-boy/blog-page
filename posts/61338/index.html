<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="JD">
    
    <title>
        
            分布式共识（Paxos） |
        
        Bean You
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jzcupid.cn","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico","favicon":"http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"何妨吟啸且徐行"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Bean You
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">分布式共识（Paxos）</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">JD</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-03-26 12:29:25
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/">凤凰架构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>在正式探讨分布式环境中面临的各种技术问题和解决方案前，我们先把目光从工业界转到学术界、学习几种具有代表性的分布式共识算法，为后续在分布式环境中操作共享数据准备好理论基础。下面笔者从一个最浅显的场景开始，引出本章的主题:</p>
<blockquote>
<p>如果你有一份很重要的数据，要确保它长期存储在电脑上不会丢失，你会怎么做?</p>
</blockquote>
<p>这不是什么脑筋急转弯的古怪问题，答案就是去买几块硬盘，在不同硬盘上多备份几个副本。假设一块硬盘每年损坏的概率是 5%，把文件复制到另一块备份盘上，两块硬盘同时损坏而丢失数据的概率就只有 0.25%，如果使用三块硬盘存储则丢失数据的概率是 0.00125%，四块是 0.0000625%，换言之，四块硬盘就可以保证数据在一年内有超过 99.9999% 的概率是安全可靠的。</p>
<p>在软件系统里，要保障系统的可靠性，采用的办法与上面用几个备份硬盘来保障的方法并没有什么区别。单个节点的系统宕机导致数据无法访问的原因可能有很多，譬如程序出错、硬件损坏、网络分区、电源故障，等等，一年中出现系统宕机的概率也许还要高于 5%，这决定了软件系统也必须有多台机器，并且它们拥有一致的数据副本，才有可能对外提供可靠的服务。</p>
<p>在软件系统里，要保障系统的可用性，面临的困难与硬盘备份面临的困难又有着本质的区别。硬盘之间是孤立的，不需要互相通信，备份数据是静态的，初始化后状态就不会发生改变，由人工进行的文件复制操作，很容易就保障了数据在各个备份盘中的一致性。然而在分布式系统中，我们必须考虑动态的数据如何在不可靠的网络通信条件下，依然能在各个节点之间正确复制的问题。将我们要讨论的场景做如下修改:</p>
<blockquote>
<p>如果你有一份会随时变动的数据，要确保它正确地存储于网络中的几台不同机器之上，你会怎么做?</p>
</blockquote>
<p>相信最容易想到的答案一定是 “数据同步”：每当数据发生变化，把变化情况在各个节点间的复制视作一种事务性的操作，只有系统里每一台机器都反馈成功、完成磁盘写人，数据的变化才宣告成功。笔者曾经在3.2节中介绍过，使用 2PC/3PC 就可以实现这种同步操作。一种真实的数据同步应用场景是数据库的主从全同步复制（Fully Synchronous Replication），譬如 MySQL 集群，它在进行全同步复制时，会等待所有 Slave 节点的 Binlog 都完成写人后，才会提交Master节点的事务。（这个场景中Binlog本身就是要同步的状态数据，不应将它看作指令日志的集合。然而这里有一个明显的缺陷，尽管可以确保 Master 节点和 Slave 节点中的数据是绝对一致的，但任何一个 Slave 节点因为任何原因未响应均会阻塞整个事务，每增加一个 Slave 节点，都会造成整个系统可用性风险增加一分。</p>
<p><strong>以同步为代表的数据复制方法，被称为状态转移（State Transfer），是较符合人类思准的可靠性保障手段，但通常要以牺牲可用性为代价。</strong>我们在建设分布式系统的时候，往往不能承受这样的代价，一些关键系统，在必须保障数据正确可靠的前提下，也对可用性有非常高的要求，譬如系统要保证数据达到 99.999999% 可靠，同时系统自身也要达到 99.999% 可用的程度。这就引出了我们的第三个问题：</p>
<blockquote>
<p>如果你有一份会随时变动的数据，要确保它正确地存储于网络中的几台不同机器之上，并且要尽可能保证数据是随时可用的，你会怎么做?</p>
</blockquote>
<p><strong>可靠性与可用性的矛盾造成了增加机器数量反而带来可用性的降低。为缓解这个矛盾在分布式系统里主流的数据复制方法是以 <font color=red>操作转移</font>（Operation Transfer）为基础的。</strong>我们想要改变数据的状态，除了直接将目标状态赋予它之外，还有另一种常用的方法是通过某种操作，令源状态转换为目标状态。<strong>能够使用确定的操作促使状态间产生确定的转移结果的计算模型，在计算机科学中被称为状态机（State Machine）</strong>。</p>
<blockquote>
<p><strong>状态机的特性</strong></p>
<p>状态机有一个特性：任何初始状态一样的状态机，如果执行的命令序列一样，则最终达到的状态也一样。如果将此特性应用在多参与者的协商共识上，可以理解为系统中存在多个具有完全相同的状态机（参与者），这些状态机能最终保持一致的关键就是起始状态完全一致和执行命令序列完全一致。</p>
</blockquote>
<p>根据状态机的特性，要让多台机器的最终状态一致，只要确保它们的初始状态是一致的。并且接收到的操作指令序列也是一致的即可，无论这个操作指令是新增、修改、删除中或是其他任何可能的程序行为，都可以理解为要将一连串的操作日志正确地广播给各个分布式节点。<strong>在广播指令与指令执行期间，允许系统内部状态存在不一致的情况，即并不要求所有节点的每一条指令都是同时开始、同步完成的，只要求在此期间的内部状态不能被外部观察到，且当操作指令序列执行完毕时，所有节点的最终状态是一致的，则这种模型就被称为 <font color=red>状态机复制</font> （State Machine Replication）。</strong></p>
<p>考虑到分布式环境下网络分区现象是不可能消除的，甚至允许不再追求系统内所有节点在任何情况下的数据状态都一致，而是采用“少数服从多数”的原则，一旦系统中过半数的节点完成了状态的转换，就认为数据的变化已经被正确地存储在了系统中，这样就可以容忍少数（通常是不超过半数）的节点失联，减弱增加机器数量对系统整体可用性的影响，这种思想在分布式中被称为 “Quorum 机制”。</p>
<p>根据上述讨论，我们需要设计出一种算法，能够让分布式系统内部暂时容忍不同的状态，但最终保证大多数节点的状态达成一致；同时，能够让分布式系统在外部看来始终表现出整体一致的结果。这个<strong>让系统各节点不受局部的网络分区、机器崩溃、执行性能或者其他因素影响，都能最终表现出整体一致的过程，就被称为各个节点的 <font color=red>协商共识</font>（Consensus）。</strong></p>
<p>最后，笔者还要提醒你注意共识与一致性的区别：<strong>一致性是指数据不同副本之间的差异，而共识是指达成一致性的方法与过程</strong>。由于翻译的关系，很多中文资料把Consensus同样翻译为一致性，导致网络上大量的“二手中文资料”将这两个概念混淆起来，如果你在网上看到“分布式一致性算法”，应明白其指的其实是“Distributed Consensus Algorithm”。</p>
<h2 id="一、Paxos"><a href="#一、Paxos" class="headerlink" title="一、Paxos"></a>一、Paxos</h2><blockquote>
<p>世界上只有一种共识协议，就是 Paxos，其他所有共识算法都是 Paxos 的退化版本。<br>                                                                            ——Mike Burrows，Google Chubby 作者</p>
</blockquote>
<p>Paxos 是由 Leslie Lamport （就是大名鼎鼎的LaTeX中的 “La” ）提出的一种基于消息专递的协商共识算法，是当今分布式系统最重要的理论基础，几乎就是“共识”二字的代名词。这个极高的评价出自于提出Raft算法的论文，更显分量十足。虽然笔者认为 Mike3urrows 所言有些夸张，但是如果没有 Paxos，那后续的 Raft、ZAB 等算法，ZooKeeper、 etcd 等分布式协调框架、Hadoop、Consul 等在此基础上的各类分布式应用都很可能会延后好几年面世。</p>
<h4 id="1-Paxos-的诞生"><a href="#1-Paxos-的诞生" class="headerlink" title="1. Paxos 的诞生"></a>1. Paxos 的诞生</h4><p>为了解释清楚 Paxos 算法，Lamport 虚构了一个名为 “Paxos” 的希腊城邦，这个城邦按照民主制度制定法律，却没有一个中心化的专职立法机构，而是靠着 “兼职议会”（Part- Time Parliament）来完成立法，无法保证所有城邦居民都能够及时了解新的法律提案，也无法保证居民会及时为提案投票。Paxos 算法的目标就是让城邦能够在每一位居民都不承诺一定会及时参与的情况下，依然可以按照少数服从多数的原则，最终达成一致意见。但是 Paxos 算法并不考虑拜占庭将军问题，即假设信息可能丢失也可能延迟，但不会被错误传递。</p>
<p>Lamport 在1990年首次发表了 Paxos 算法，选的论文题目就是 “The Part-Time Parliament” 由于算法本身极为复杂，用希腊城邦作为比喻反而使得描述更晦涩，论文的三个审稿人一致要求他把希腊城邦的故事删掉。这令Lamport感觉颇为不爽，干脆就撤稿不发了，所以 Paxos刚刚被提出的时候并没有引起什么反响。八年之后（1998年），Lamport 将此文章重整理后投到 ACM Transactions on Computer Systems。这次论文成功发表，Lamport的名也确实吸引了一些人去研究，但并没有多少人能弄懂他在说什么。时间又过去了三年（200年），Lamport认为前两次的论文没有引起反响，是因为同行们无法理解他以“希腊城邦”来讲故事的幽默感，所以这一次他以“Paxos Made Simple”为题，在SIGACT News 杂志上表文章，放弃了“希腊城邦”的比喻，尽可能用（他认为）简单直接、（他认为）可读性较强的方式去介绍Paxos算法。情况虽然比前两次要好上一些，但以Paxos本应获得的重视程来说，这次依然只能算是应者寥寥。这一段听起来如同网络段子一般的经历被Lamport 以自嘲的形式放到了他的个人网站上。尽管我们作为后辈应该尊重Lamport老爷子，但当笔翻开“Paxos Made Simple”的论文，见到只有“The Paxos algorithm, when presented in plain English, is very simple.”这一句话的“摘要”时，心里实在是不得不怀疑Lamport 这样写论文是不是在恶搞审稿人和读者，在嘲讽“你们这些愚蠢的人类”。</p>
<p>虽然Lamport本人连发三篇文章都没能让大多数同行理解Paxos，但2006年，在 Google的Chubby、Megastore以及Spanner等分布式系统都使用Paxos 解决了分布式共识的问题，并将其整理成正式的论文发表之后，得益于Google的行业影响力，辅以Chubby作者Mike Burrows那略显夸张但足够吸引眼球的评价推波助澜，Paxos算法一夜间成为计算机科学分布式这条分支中最炙手可热的概念，开始被学术界众人争相研究。Lamport 本人因其对分布式系统的杰出理论贡献获得了2013年的图灵奖，随后才有了 Paxos 在区块链、分布式系统、云计算等多个领域大放异彩的故事。</p>
<h4 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h4><p>下面，我们来正式学习 Paxos 算法（在本节中 Paxos 均特指最早的 Basic Paxos 算法）。</p>
<p>Paxos 算法将分布式系统中的节点分为三类。</p>
<ul>
<li><strong>提案节点（Proposer）</strong>：提出对某个值进行设置操作的节点，设置值这个行为就被称为提案（Proposal），值一旦设置成功，就是不会丢失也不可变的。注意，Paxos是典型的基于操作转移模型而非状态转移模型来设计的算法，不要把这里的“设置值”类比成程序中变量赋值操作。而应该类比成日志记录操作，在后面介绍的Raft<br>算法中就直接把“提案”叫作“日志”了。</li>
<li><strong>决策节点（Acceptor）</strong>：是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被批准（Accept）。提案被批准即意味着该值不能被更改，也不会丢失，且最终所有节点都会接受它。</li>
<li><strong>记录节点（Learner）</strong>：不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。</li>
</ul>
<p>在使用Paxos算法的分布式系统里，所有的节点都是平等的，它们都可以承担以上某一种或者多种的角色。不过为了便于确保有明确的多数派，决策节点的数量应该被设定为奇数个，且在系统初始化时，网络中每个节点都应该知道整个网络所有决策节点的数量地址等信息。</p>
<p>在分布式环境下，如果我们说各个节点 “就某个值（提案）达成一致”，指的是 “不存在某个时刻有一个值为A，另一个时刻又为B的情景”。解决这个问题的复杂度主要来源于以下两个方面因素的共同影响。</p>
<ul>
<li>系统内部各个节点通信是不可靠的，不论是对于系统中企图设置数据的提案节点抑或是决定是否批准设置操作的决策节点，其发出、收到的信息可能延迟送达、可能丢失，但不去考虑消息有传递错误的情况。</li>
<li>系统外部各个用户访问是可并发的，如果系统只会有一个用户，或者每次只对系统进行串行访问，那单纯地应用 Quorum 机制，少数节点服从多数节点，就足以保证值被正确地读写。</li>
</ul>
<p>第一点是网络通信中客观存在的现象，也是所有共识算法都要重点解决的问题。对于第二点，详细解释如下。现在我们讨论的是 “分布式环境下并发操作的共享数据” 的问题即使先不考虑是否在分布式的环境下，只考虑并发操作，假设有一个变量 i 当前在系统中存储的数值为2，同时有外部请求A、B分别对系统发送操作指令，“把 i 的值加1” 和 “把 i 的值乘3”，如果不加任何并发控制，将可能得到 “(2+1)x3=9” 与 “2x3+1=7” 这两种可能的结果。因此，对同一个变量的并发修改必须先加锁后操作，不能让A、B的请求被交替处理，这也可以说是程序设计的基本常识。而在分布式的环境下，由于要同时考虑到分布式系统内可能在任何时刻出现的通信故障，如果一个节点在取得锁之后、在释放锁之前发生崩溃失联，这将导致整个操作被无限期的等待所阻塞，因此算法中的加锁就不完全等同于并发控制中以互斥量来实现的加锁，还必须提供一个其他节点能抢占锁的机制，以避免因通信问题而出现死锁。</p>
<p>为了解决这个问题、分布式环境中的锁必须是可抢占的。Paxos算法包括两个阶段，一阶段“准备”（Prepare）就相当于上面抢占锁的过程。如果某个提案节点准备发起提案。必须先向所有的决策节点广播一个许可申请（称为Prepare 请求）。提案节点的 Prepare 请求中会附带一个全局唯一且单调递增的数字n作为提案ID，决策节点收到后，将会给予提案节点两个承诺与一个应答。</p>
<p><strong>两个承诺是指：</strong></p>
<ul>
<li>承诺不会再接受提案ID小于或等于 n 的 Prepare 请求:</li>
<li>承诺不会再接受提案ID小于 n 的 Accept 请求。</li>
</ul>
<p><strong>一个应答是指：</strong></p>
<ul>
<li>在不违背以前的承诺的前提下，回复已经批准过的提案中ID最大的那个提案所定的值和提案ID，如果该值从来没有被任何提案设定过，则返回空值。如果违反此前做出的承诺，即收到的提案ID并不是决策节点收到的最大的ID，那允许直接对此 Prepare 请求不予理会。</li>
</ul>
<p>当提案节点收到了多数派决策节点的应答（称为 Promise 应答）后，就可以开始第二阶段的“批准”（ Accept ）过程，这时有如下两种可能的结果:</p>
<ul>
<li>如果提案节点发现所有响应的决策节点此前都没有批准过该值（即为空），那说明它是第一个设置值的节点，可以随意地决定要设定的值，将自己选定的值与提案ID组成一个二元组“（id, value）”，再次广播给全部决策节点（称为 Accept 请求）;</li>
<li>如果提案节点发现响应的决策节点中已经有至少一个节点的应答中包含值了，那它就不能够随意取值，而是必须无条件地从应答中找出提案ID最大的那个值并接收，组成一个二元组“（id, maxAcceptValue）”，再次广播给全部决策节点（称为 Accept 请求）。</li>
</ul>
<p>当每一个决策节点收到 Accept 请求时，都会在不违背以前的承诺的前提下。接收并持久化当前提案ID和提案附带的值。如果违反此前做出的承诺，即收到的提案ID并不是决策节点收到过的最大的ID，那允许直接对此Accept请求不予理会。</p>
<p>当提案节点收到了多数派决策节点的应答（称为 Accepted 应答）后，协商结束，共识决议形成，然后将形成的决议发送给所有记录节点进行学习。整个过程的时序图如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/Paxos%20%E7%AE%97%E6%B3%95%E6%95%B4%E4%BD%93%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Paxos 算法整体时序图"></p>
<p>整个 Paxos 算法的工作流程至此结束，如果你此前并未专门学习过分布式的知识，可能还不能对Paxos算法究竟是如何解决协商共识的形成具体的概念。下面笔者以一个更具体例子来讲解 Paxos。</p>
<h4 id="3-工作实例"><a href="#3-工作实例" class="headerlink" title="3. 工作实例"></a>3. 工作实例</h4><p>假设一个分布式系统有五个节点，分别命名为S1、S2、S3、S4、S5，五个节点都同时扮演着提案节点和决策节点的角色。这个例子中只讨论正常通信的场景，不涉及网络分区。</p>
<p>此时，有两个并发的请求希望将同一个值分别设定为 X（由 S1 作为提案节点提出）和 Y （由 S5 作为提案节点提出），以 P 代表准备阶段，以 A 代表批准阶段，这时可能发生以下几种情况。</p>
<ul>
<li><p>情况一：譬如，S1 选定的提案ID是 3.1 （全局唯一ID加上节点编号），先取得了多数派决策节点的 Promise 和 Accepted 应答，此时 S5 选定提案ID 4.5，发起 Prepare 请求，收到的多数应答中至少会包含 1 个此前应答过 S1 的决策节点，假设是 S3，那么 S3 提供的 Promise 中必将包含 S1 已设定好的值 X，S5 就必须无条件地用 X 代替 Y 作为自己提案的值，由此整个系统对 “取值为 X” 这个事实达成一致，如图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%8F%96%E5%80%BC%E4%B8%BAX%E8%BE%BE%E6%88%90%E4%B8%80%E8%87%B4.png" alt="整个系统对取值为X达成一致"></p>
</li>
<li><p>情况二：事实上，对于情况一，X 被选定为最终值是必然结果，但从上图中可以看出，X 被选定为最终值并不是必须得到多数派的共同批准，而是只取决于 S5 提案时 Promise 应答中是否已包含了批准过 X 的决策节点，譬如下图所示，S5 发起提案的 Prepare 请求时，X 并未获得多数派批准，但由于 S3 已经批准，所以最终共识的结果仍是 X。</p>
</li>
</ul>
<p><img src="http://qiniu.jzcupid.cn/blog/X%E8%A2%AB%E9%80%89%E5%AE%9A%E5%8F%AA%E5%8F%96%E5%86%B3%E4%BA%8EPromise%E5%BA%94%E7%AD%94%E4%B8%AD%E6%98%AF%E5%90%A6%E5%B7%B2%E6%89%B9%E5%87%86.png" alt="X被选定只取决于Promise应答中是否已批准"></p>
<ul>
<li>情况三：另外一种可能的结果是 S5 提案时 Promise 应答中并未包含批准过 X 的决策节点，譬如应答 S5 提案时，节点 S1 已经批准了 X，节点 S2、S3 未批准但返回了 Promise 应答，此时 S5 以更大的提案 ID 获得了 S3、S4、S5 的 Promise 应答，由于这三个节点均未批准过任何值，所以 S3 将不再接收来自 S1 的 Accept 请求，因为它的提案 ID 已经不是最大的了，这三个节点将批准 Y 的取值，整个系统最终会对 “取值为Y” 达成一致，如下图所示。</li>
</ul>
<p><img src="http://qiniu.jzcupid.cn/blog/%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%9C%80%E7%BB%88%E5%AF%B9%E5%8F%96%E5%80%BC%E4%B8%BAY%E8%BE%BE%E6%88%90%E4%B8%80%E8%87%B4.png" alt="整个系统最终对取值为Y达成一致"></p>
<ul>
<li>情况四：从情况三可以推导出另一种极端的情况，如果两个提案节点交替使用更大的提案 ID，使得准备阶段成功、批准阶段失败，那么这个过程理论上可以无限持续下去、形成活锁（Live Lock），如下图所示。在算法实现中会引入随机超时时间来避免活锁的产生。</li>
</ul>
<p><img src="http://qiniu.jzcupid.cn/blog/%E6%89%B9%E5%87%86%E9%98%B6%E6%AE%B5%E5%A4%B1%E8%B4%A5%E5%BD%A2%E6%88%90%E6%B4%BB%E9%94%81.png" alt="批准阶段失败形成活锁"></p>
<p>虽然 Paxos 是以复杂著称的算法，但以上介绍都是基于 <strong>Basic Paxos</strong>、以正常流程（未出现网络分区等异常）、通俗方式讲解的 Paxos 算法，并未涉及严谨的逻辑和数学原理，也未讨论 Paxos 的推导证明过程，理解起来应该不算太困难。</p>
<p><strong>Basic Paxos</strong> 的价值在于开拓了分布式共识算法的发展思路，但由于它有如下缺陷。一般不会直接用于实践：</p>
<p><strong>Basic Paxos</strong> 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下将产生较大的网络开销，极端情况下甚至可能形成活锁。总之，<strong>Basic Paxos</strong> 是一种很学术化但对工业化并不友好的算法现在几乎只用来做理论研究，实际的应用都是基于 <strong>Multi Paxos</strong> 和 <strong>Fast Paxos</strong> 算法，接下来我们将会了解 <strong>Multi Paxos</strong> 以及一些与它的理论等价的算法（如 Raft、ZAB 等算法）。</p>
<h2 id="二、-Multi-Paxos"><a href="#二、-Multi-Paxos" class="headerlink" title="二、 Multi Paxos"></a>二、 Multi Paxos</h2><p>在上一节的最后，举例介绍了 <strong>Basic Paxos</strong> 的活锁问题，即两个提案节点争相提出自己的提案，抢占同一个值的修改权限，导致整个系统在持续性地 “反复横跳”，外部看起来就像被锁住了一样。此外，笔者还讲述过一个观点，分布式共识的复杂性主要来源于网络的不可靠与请求的可并发两大因素，活锁问题与许多 <strong>Basic Paxos</strong> 异常场景中所遭遇的麻烦，都可以看作源于任何一个提案节点都能够完全平等地、与其他节点并发地提出提案而带来的复杂问题。为此，Lamport 提出了一种 Paxos 的改进版本—— <strong>Multi Paxos</strong> 算法，望能够找到一种两全其美的办法，既不破坏 Paxos 中 “众节点平等” 的原则，又能在提节点中实现主次之分，限制每个节点都有不受控的提案权利。这两个目标听起来似乎是矛盾的，但现实世界中的选举就很符合这种在平等节点中挑选意见领袖的情景。</p>
<p><strong>Multi Paxos</strong> 对 <strong>Basic Paxos</strong> 的核心改进是增加了“选主”的过程，提案节点会通过定时轮询（心跳），确定当前网络中的所有节点里是否存在一个主提案节点，一旦没有发现主节点，节点就会在心跳超时后使用 <strong>Basic Paxos</strong> 中定义的准备、批准的两轮网络交互过程，向所有其他节点广播自己希望竞选主节点的请求，希望整个分布式系统对 “由我作为主节点“ 这件事情协商达成一致共识，如果得到了决策节点中多数派的批准，便宣告竞选成功。选主完成之后，除非主节点失联之后发起重新竞选，否则从此往后，就只有主节点本身才能够提出提案。此时，无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案时，就无须再次经过准备过程，因为可以认为在经过选举时的那一次准备之后，后续的提案都是对相同提案ID的一连串的批准过程。也可以通俗理解为选主过后，就不会再有其他节点与它竞争，相当于处于无并发的环境当中的有序操作，所以此时系统中要对某个值达成一致，只需要进行一次批准的交互即可，如图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/MultiPaxos%E7%AE%97%E6%B3%95%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="MultiPaxos算法时序图"></p>
<p>可能有人注意到这时候的二元组（id, value）已经变成了三元组（id, i, value），这是因为需要给主节点增加一个 “任期编号”，这个编号必须是严格单调递增的，以应付主节点陷人网络分区后重新恢复，但另外一部分节点仍然有多数派，且已经完成了重新选主的情况，此时必须以任期编号大的主节点为准。节点有了选主机制的支持后，在整体来看，就可以进一步简化节点角色，不去区分提案、决策和记录节点，而是统统以 “节点” 来代替，节点只有主（Leader）和从（Follower）的区别，此时协商共识的时序图如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E6%9C%89%E9%80%89%E4%B8%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8D%8F%E5%95%86%E5%85%B1%E8%AF%86%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="有选主机制的协商共识的时序图"></p>
<p>下面我们换一个角度来重新思考 “分布式系统中如何对某个值达成一致” 这个问题，可以把该问题划分为三个子问题来考虑，可以证明（具体证明就不列在这里了，感兴趣的读者可参考 Raft 的论文）当以下三个问题同时被解决时，即等价于达成共识:</p>
<ul>
<li>如何选主（Leader Election）</li>
<li>如何把数据复制到各个节点上（EntityReplication）</li>
<li>如何保证过程是安全的（Safety）</li>
</ul>
<p>尽管选主问题还涉及许多工程上的细节，譬如心跳、随机超时、并行竞选等，但只论原理的话，如果你已经理解了Paxos算法的操作步骤，相信对选主并不会有什么疑惑，因为这本质上仅仅是分布式系统对 “谁来当主节点” 这件事情达成的共识而已，我们在前一节已经讲述了分布式系统该如何对一件事情达成共识，这里就不再赘述了，下面直接来解决数据（Paxos 中的提案、Raft中的日志）在网络各节点间的复制问题。</p>
<p>在正常情况下，客户端向主节点发起一个操作请求，譬如提出 “将某个值设置为X” 。此时主节点将 X 写入自己的变更日志，但先不提交，接着在下一次心跳包中把变更 X 的信息广播给所有的从节点，并要求从节点回复 “确认收到” 的消息，从节点收到信息后，将操作写入自己的变更日志，然后向主节点发送 “确认签收” 的消息，主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播可以提交的消息，从节点收到提交消息后提交自己的变更，至此，数据在节点间的复制宣告完成。</p>
<p>在异常情况下，网络出现了分区，部分节点失联，但只要仍能正常工作的节点的数量能够满足多数派（过半数）的要求，分布式系统就可以正常工作，这时的数据复制过程如下。</p>
<ul>
<li><p>假设有S1、S2、S3、S4、S5 五个节点，s1 是主节点，由于网络故障，导致S1、s2 和 S3、S4、s5 之间彼此无法通信，形成网络分区。</p>
</li>
<li><p>一段时间后，S3、S4、s5 三个节点中的某一个（譬如是S3）最先达到心跳超时的阙值，获知当前分区中已经不存在主节点，则它向所有节点发出自己要竞选的广播，并收到了S4、S5 节点的批准响应，加上自己一共三票，即得到了多数派的批准，竞选成功，此时系统中会同时存在 S1 和 S3 两个主节点，但由于网络分区，它们不会知道对方的存在。</p>
</li>
<li><p>这种情况下，客户端发起操作请求。</p>
<ul>
<li><p>如果客户端连接到了 S1、S2 其中之一，都将由 S1 处理。但由于操作只能获得最多两个节点的响应，不构成多数派的批准，所以任何变更都无法成功提交。</p>
</li>
<li><p>如果客户端连接到了 S3、S4、s5 其中之一，都将由 S3 处理，此时操作可以获得最多三个节点的响应、构成多数派的批准，是有效的，变更可以被提交，即系统可以继续提供服务。</p>
</li>
<li><p>事实上，以上两种情景很少能够并存。网络分区是由于软、硬件或者网络故障面导致的、内部网络出现了分区，但两个分区仍然能分别与外部网络的客户端正常通信的情况甚为少见。更多的场景是算法能容忍网络里下线了一部分节点，按照这个例子来说，如果下线了两个节点，系统仍能正常工作，如果下线了三个节点，那剩余的两个节点就不可能继续提供服务了。</p>
</li>
</ul>
</li>
<li><p>假设现在障复，分区解除，五个节点可以重新通信：</p>
<ul>
<li>S1 和 S3 都向所有节点发送心跳包，从各自的心跳中可以得知两个主节点里 S3 的任期编号更大，它是最新的，此时五个节点均只承认 S3 是唯一的主节点。 </li>
<li>S1、S2 回滚它们所有未被提交的变更。</li>
<li>S1、S2 从主节点发送的心跳包中获得它们失联期间发生的所有变更，将变更提交并写人本地磁盘。</li>
<li>此时分布式系统各节点的状态达成最终一致。</li>
</ul>
</li>
</ul>
<p>下面我们来看第三个问题：“如何保证过程是安全的”。不知你是否感觉到这个问题与前两个问题的差异呢？选主、数据复制都是很具体的行为，但是 “安全” 就很模糊，什么算安全或者算不安全？</p>
<p>在分布式理论中，Safety 和 Liveness 两种属性是有预定义的术语，在专业的资料中一般翻译成 “协定性” 和 “终止性” 。这两个概念也是由 Lamport 最先提出，当时给出的定义如下。</p>
<ul>
<li><strong>协定性（Safety）</strong>：所有的坏事都不会发生。</li>
<li><strong>终止性（Liveness）</strong>：所有的好事都终将发生，但不知道是什么时候。</li>
</ul>
<p>这里我们不去纠结严谨的定义，仍通过举例来说明它们的具体含义。譬如以选主问题为例，协定性保证了选主的结果一定有且只有唯一的一个主节点，不可能同时出现两个主节点；而终止性则要保证选主过程一定可以在某个时刻结束。由前面对活锁的介绍可知，在终止性这个属性上选主问题是存在理论上的瑕疵的，可能会由于活锁而导致一直无法选出明确的主节点。所以 Raft 论文中只写了对 Safety 的保证，但由于工程实现上的处理，现实中几乎不可能会出现终止性的问题。</p>
<p>以上这种把共识问题分解为 “选主”、“复制” 和 “安全” 三个问题来思考、解决的思路，即 “Raft算法” （在 Raft 的《一种可以让人理解的共识算法》中提出），并获得了 USENIX ATC 2014 大会的 Best Paper，后来更是成为eted、LogCabin、Consul 等重要分布式程序的实现基础，ZooKeeper 的 ZAB 算法与 Raft 的思路也非常类似，这些算法都被认为是 Multi Paxos 的等价派生实现。</p>
<h2 id="三、Gossip协议"><a href="#三、Gossip协议" class="headerlink" title="三、Gossip协议"></a>三、Gossip协议</h2><p>Paxos、Raf、ZAB 等分布式算法经常会被称作 “强一致性” 的分布式共识协议，其实样的描述有语病嫌疑。但我们都明白它的意思其实是：<strong>“尽管系统内部节点可以存在不一的状态。但从系统外部看来，不一致的情况并不会被观察到，所以整体上看系统是强一致性的。</strong>”</p>
<p>与它们相对的，还有另一类被冠以 “<strong>最终一致性</strong>” 的分布式共识协议，这表明系统中不一致的状态有可能会在一定时间内被外部直接观察到。一种典型且极为常见的最终一致的分布式系统就是DNS系统，在各节点缓存的 TTL 到期之前，都有可能与真实的域名翻译结果不一致。在本节中，笔者将介绍在比特币网络和许多重要分布式框架中都有应用的另一种具有代表性的 “<strong>最终一致性</strong>” 的分布式共识协议：Gossip 协议。</p>
<p>Gossip 最早由施乐公司Palo Alto 研究中心在论文 “Epidemic Algorithms for Replicated Database Maintenance” 中提出的一种用于分布式数据库在多节点间复制同步数据的算法。从论文题目中可以看出，最初它是被称作 “流行病算法” （Epidemic Algorithm）的，只是不太雅观，今天 Gossip 这个名字用得更为普遍，除此以外，它还有“流言算法” “八卦算法” “瘟疫算法” 等别名，这些名字都很形象地反映了 Gossip 的特点：要同步的信息如同流言一般传播，病毒一般扩散。</p>
<p>笔者按照习惯也把 Gossip 称作 “共识协议”，但首先必须强调它并不是直接与 Paxos Raft 这些共识算法等价的，只是基于 Gossip 之上可以通过某些方法去实现与 Paxos、Raft 类似的目标而已。一个最典型的例子是比特币网络中使用了 Gossip 协议，用于在各个分布式节点中互相同步区块头和区块体的信息，这是整个网络能够正常交换信息的基础，但并不能称作共识；然后比特币使用工作量证明（ProofofWork，PoW）来对 “这个区块由谁来记账” 这一件事情在全网达成共识，这样这个目标才可以认为与 Paxos、Raft 的目标是一致的。</p>
<p>下面，我们来了解 Gossip 的具体工作过程。相比 Paxos、Raft 等算法，Gossip 的过程十分简单，它可以看作以下两个步骤的简单循环。</p>
<ul>
<li>如果有某一项信息需要在整个网络的所有节点中传播，那从信息源开始，选择一个固定的传播周期（譬如1秒）。随机选择它相连接的 k 个节点（称为 Fan-Out）来传播消息。</li>
<li>每一个节点收到消息后，如果这个消息是它之前没有收到过的，则在下一个周期内，该节点将向除了发送消息给它的那个节点外的其他相邻的 k 个节点发送相同的消息，直到最终网络中所有节点都收到了消息。尽管这个过程需要一定时间，但是理论上最终网络的所有节点都会拥有相同的消息。</li>
</ul>
<p>根据 Gossip 的过程描述，我们很容易发现 Gossip 对网络节点的连通性和稳定性几乎没有任何要求，它一开始就将网络某些节点只能与一部分节点部分连通（Partially Connected Network）而不是以全连通网络（Fully Connected Network）作为前提；能够容忍网络上节点随意地增加或者减少，随意地宕机或者重启；新增加或者重启的节点的状态最终会与其他节点同步达成一致。Gossip 把网络上所有节点都视为平等而普通的一员，没有任何中心化节点或者主节点的概念，这些特点使得 Gossip 具有极强的鲁棒性，而且非常适合在公众互联网中应用。</p>
<p>同时我们也很容易找到 Gossip 的缺点。消息最终是通过多个轮次的散播到达全网的因此它必然会存在全网各节点状态不一致的情况，而且由于是随机选取发送消息的节点，所以尽管可以在整体上测算出统计学意义上的传播速率，但对于个体消息来说，无法准确地预计需要多长时间才能达成全网一致。另外一个缺点是消息的冗余，同样是由于随机选取发送消息的节点，所以就不可避免地存在消息重复发送给同一节点的情况，增加了网络的传输压力，也给消息节点带来了额外的处理负载。</p>
<p>达到一致性耗费的时间与网络传播中消息冗余量这两个缺点存在一定对立，如果要改善其中一个，就会恶化另外一个，由此，Gossip 设计了两种可能的消息传播模式：反熵（Anti-Entropy）和传谣（Rumor-Mongering）。熵（Entropy）是生活中少见但科学中很常用的概念，它代表着事物的混乱程度。反熵的意思就是反混乱，以提升网络各个节点之间的相似度为目标。所以在反熵模式下，会同步节点的全部数据，以消除各节点之间的差异，目标是使整个网络各节点完全一致。但是，在节点本身就会发生变动的前提下，这个目标将使得整个网络中消息的数量非常庞大，给网络带来巨大的传输开销。而传谣模式是以传播消息为目标，只发送新到达节点的数据，即只对外发送变更消息，这样消息数据量将显著缩减，网络开销也相对减小。</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/posts/30029/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Kryo 序列化</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/posts/54537/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Javaagent</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">JD</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Paxos"><span class="nav-text">一、Paxos</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Paxos-%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-text">1. Paxos 的诞生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 算法流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B7%A5%E4%BD%9C%E5%AE%9E%E4%BE%8B"><span class="nav-text">3. 工作实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-Multi-Paxos"><span class="nav-text">二、 Multi Paxos</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81Gossip%E5%8D%8F%E8%AE%AE"><span class="nav-text">三、Gossip协议</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
