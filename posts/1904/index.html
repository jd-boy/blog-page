<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="JD">
    
    <title>
        
            Java 内存模型 |
        
        Bean You
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jzcupid.cn","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico","favicon":"http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"莫听穿林打叶声，何妨吟啸且徐行。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Bean You
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java 内存模型</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="http://qiniu.jzcupid.cn/blog%E5%9B%BE%E6%A0%87.ico">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">JD</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-11-13 15:13:50
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Java/">Java</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/Java/JVM/">JVM</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/">深入理解JVM虚拟机（第三版）</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>《Java虚拟机规范》中曾试图定义一种 “Java内存模型”（Java Memory Model，JMM）来 <strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</strong></p>
<p>定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发访问操作不会产生歧义。</p>
<p>但是也必须定义得足够宽松，是的虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好执行速度。</p>
<p>Java内存模型在 JDK1.2 之后建立起来，直到 JDK5 （JSR-133）发布后，Java内存模型才终于成熟、完善起来。</p>
<blockquote>
<p>在《Java虚拟机规范》的第2版及之前，专门有一章 “Threads and Locks” 来描述内存模型，后来由于这部分内容难以把握宽紧限度，被反复修正更新，从第3版（Java SE 7版）开始索性就被移除出规范，独立以 JSR 形式维护。</p>
</blockquote>
<h2 id="1-Java内存模型作用"><a href="#1-Java内存模型作用" class="headerlink" title="1. Java内存模型作用"></a>1. Java内存模型作用</h2><p>Java 内存模型的主要目的是定义程序中各种 <strong>变量</strong> 的访问规则，即关注 <strong>在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</strong>。</p>
<p>此处的变量与 Java 编程中所说的变量有所区别，它包括了：</p>
<ul>
<li>实例字段</li>
<li>静态字段</li>
<li>构成数组对象的元素</li>
</ul>
<p>但是不包括 <strong>局部变量</strong> 与 <strong>方法参数</strong>，因为后者 <strong>是线程私有的</strong>，不会被共享，自然不存在竞争问题。</p>
<blockquote>
<p>如果局部变量是一个 reference 类型，它引用的对象在Java堆中可被各个线程共享，但是 reference 本身在Java栈的局部变量表中是线程私有的。</p>
</blockquote>
<p>为了获得更好的执行效能，Java内存模型 <strong>并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存交互</strong>， <strong>也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施</strong>。</p>
<h2 id="2-主内存与工作内存"><a href="#2-主内存与工作内存" class="headerlink" title="2. 主内存与工作内存"></a>2. 主内存与工作内存</h2><p><strong>主内存</strong>、<strong>工作内存</strong> 与Java内存区域的 <strong>Java堆</strong>、<strong>栈</strong>、<strong>方法区</strong> 等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。</p>
<p>如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，</p>
<p><strong>主内存主要对应于Java堆中的对象实例数据部分</strong></p>
<blockquote>
<p>之所以说对应的是Java堆中的对象实例数据，是因为：</p>
<p>除了实例数据，Java堆还保存了对象的其他信息，对于 HotSpot 虚拟机来讲，有 Mark word（存储对象哈希码、GC标志、GC年龄、同步锁等信息）、Klass Point（指向存储类型元数据的指针）及一些用于字节码对齐补白的填充数据（如果实例数据刚好满足 8 字节对齐，则可以不补白）。</p>
</blockquote>
<p><strong>工作内存对应于虚拟机栈的部分区域</strong></p>
<p>从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</p>
<h3 id="2-1-主内存"><a href="#2-1-主内存" class="headerlink" title="2.1 主内存"></a>2.1 主内存</h3><p>Java 内存模型规定了所有的变量都存储在主内存。</p>
<blockquote>
<p>此处的主内存与物理硬件的主内存名字一样，两者也可以类比，但 <strong>物理上它仅是虚拟机内存的一部分</strong>。</p>
</blockquote>
<h4 id="2-2-工作内存"><a href="#2-2-工作内存" class="headerlink" title="2.2 工作内存"></a>2.2 工作内存</h4><p>每条线程都有自己的工作内存。</p>
<p><strong>（1）线程的工作内存中保存了被该线程使用的变量的主内存副本</strong>。</p>
<blockquote>
<p>假如线程中访问一个 10MB 大小的对象，也会把这 10MB 的内存复制一份出来吗？</p>
<p>事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段是有可能被复制的，但不会有虚拟机把整个对象复制一次。</p>
</blockquote>
<p><strong>（2）线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读取主内存中的数据</strong>。</p>
<blockquote>
<p>根据《Java虚拟机规范》的规定，volatile 变量依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于 volatile 也并不存在例外。</p>
</blockquote>
<p><strong>（3）不同的线程之间无法直接访问对方工作内存中的变量</strong>。</p>
<p><strong>（4）线程间变量值的传递均需要通过主内存来完成</strong>。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="关系图"></p>
<h2 id="3-内存间交互操作"><a href="#3-内存间交互操作" class="headerlink" title="3. 内存间交互操作"></a>3. 内存间交互操作</h2><h3 id="3-1-八种基本操作"><a href="#3-1-八种基本操作" class="headerlink" title="3.1 八种基本操作"></a>3.1 八种基本操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，<strong>Java 内存模型</strong> 中定义了以下 8 种操作来完成。</p>
<blockquote>
<p><strong>Java 虚拟机实现时必须保证下面提到的每一种操作都是原子的、不可再分的</strong>。</p>
<p>对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外。</p>
</blockquote>
<ul>
<li><strong>lock（锁定）：</strong> 作用于 <strong>主内存</strong> 的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><strong>unlock（解锁）：</strong> 作用于 <strong>主内存</strong> 的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read（读取）：</strong> 作用于 <strong>主内存</strong> 的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>
<li><strong>load（载入）：</strong>作用于 <strong>工作内存</strong> 的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use（使用）：</strong>作用于 <strong>工作内存</strong> 的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时，将会执行这个操作。</li>
<li><strong>assign（赋值）：</strong>作用于 <strong>工作内存</strong> 的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）：</strong>作用于 <strong>工作内存</strong> 的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>
<li><strong>write（写入）：</strong>作用于 <strong>主内存</strong> 的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行 <strong>read</strong> 和 <strong>load</strong> 操作，</p>
<p>如果要把变量从工作内存同步回主内存，就要按顺序中 <strong>store</strong> 和 <strong>write</strong> 操作。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>Java 内存模型只要求上述两个操作必须按顺序执行，但不要求连续执行。</p>
<p>也就是说 read 和 load 之间、store 与 write 之间是可以插入其他指令的。</p>
<p>如果对主内存中的变量a、b进行访问时，一种可能出现的顺序是 read a、read b、load b、load a。</p>
</blockquote>
<h3 id="3-2-八种操作必须满足的规则"><a href="#3-2-八种操作必须满足的规则" class="headerlink" title="3.2 八种操作必须满足的规则"></a>3.2 八种操作必须满足的规则</h3><ol>
<li>不允许 <strong>read</strong> 和 <strong>load</strong> 、<strong>store</strong> 和 <strong>write</strong> 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起了回写但主内存不接受的情况。</li>
<li>不允许一个线程丢弃它最近的 <strong>assign</strong> 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何 <strong>assign</strong> 操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（<strong>load</strong> 或 <strong>assign</strong>）的变量，换句话说就是对一个变量实施 <strong>use</strong>、<strong>store</strong> 操作之前，必须先执行 <strong>assign</strong> 和 <strong>load</strong> 操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行 <strong>lock</strong> 操作，但 <strong>lock</strong> 操作可以被同一条线程重复执行多次，多次执行 <strong>lock</strong> 后，只有执行相同次数的 <strong>unlock</strong> 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 <strong>lock</strong> 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 <strong>load</strong> 或 <strong>assign</strong> 操作以初始化变量的值。</li>
<li>如果一个变量事先没有被 <strong>lock</strong> 操作锁定，那就不允许对它执行 <strong>unlock</strong> 操作，也不允许去 <strong>unlock</strong> 一个被其他线程锁定的变量。</li>
<li>对一个变量执行 <strong>unlock</strong> 操作之前，必须先把此变量同步回主内存（执行 <strong>store</strong> 、<strong>write</strong> 操作）。</li>
</ol>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>这 8 种内存访问操作以及上述规则限定，再加上 <strong>volatile</strong> 的一些特殊规定，就已经能够准确地描述出 Java 程序中哪些内存访问操作在并发下才是安全的。</p>
<p>这种定义相当严谨，但也是极为烦琐，后来 Java 设计团队将 Java 内存模型的操作简化为 <strong>read、write、lock 和 unlock</strong> 四种，但 <strong>这只是语言描述上的等价化简，Java 内存模型的基础设计并未改变</strong>。</p>
<h2 id="4-volatile-型变量的特殊规则"><a href="#4-volatile-型变量的特殊规则" class="headerlink" title="4. volatile 型变量的特殊规则"></a>4. volatile 型变量的特殊规则</h2><p>关键字 <strong>volatile</strong> 可以说是 Java 虚拟机提供的 <strong>最轻量级的同步机制</strong>。</p>
<h3 id="4-1-volatile-修饰的变量两个特性"><a href="#4-1-volatile-修饰的变量两个特性" class="headerlink" title="4.1 volatile 修饰的变量两个特性"></a>4.1 volatile 修饰的变量两个特性</h3><h4 id="（1）保证此变量对所有线程的可见性"><a href="#（1）保证此变量对所有线程的可见性" class="headerlink" title="（1）保证此变量对所有线程的可见性"></a>（1）保证此变量对所有线程的可见性</h4><p>这里的 <strong>“可见性”</strong> 是指 <strong>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</strong>。</p>
<p>而 <strong>普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成</strong>。</p>
<p><strong>volatile</strong> 变量在各个线程的工作内存中是不存在一致性问题的。</p>
<blockquote>
<p>从物理存储的角度看，各个线程的工作内存中 volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题）</p>
</blockquote>
<p>但是 <strong>Java 里面的运算操作符并非原子操作，这导致 volatile 变量的运算在并发下一样是不安全的</strong>。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>由于 <strong>volatile</strong> 变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍要通过加锁来保证原子性：</p>
<ol>
<li>运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>
<h4 id="（2）禁止指令重排序优化"><a href="#（2）禁止指令重排序优化" class="headerlink" title="（2）禁止指令重排序优化"></a>（2）禁止指令重排序优化</h4><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而 <strong>不能保证变量赋值操作的顺序与程序中的执行顺序一致</strong>。</p>
<p>这就是 Java 内存模型中描述的所谓 <strong>“线程内表现为串行的语义“</strong>。</p>
<h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><p>在汇编代码中，被 <strong>volatile</strong> 修饰的变量，在赋值后，多执行了一个 <strong>“lock add1 $0x0,(%sep)”</strong> 操作。</p>
<p>这个操作的作用相当于一个内存屏障，只有一个处理器访问内存时，并不需要内存屏障。</p>
<p>但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p>
<p>这句指令中的 <strong>“add1 $0x0,(%sep)”</strong> （把 ESP 寄存器的值加0）显然是一个空操作，之所以用这个空操作而不是空操作专用指令 <strong>nop</strong> ，是因为 IA32 手册规定 <strong>lock</strong> 前缀不允许配合 <strong>nop</strong> 指令使用。</p>
<p>这里的 <strong>lock</strong> 前缀，作用是 <strong>将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核无效化其缓存</strong>。</p>
<p>这种操作相当于对缓存中的变量做了一次前面介绍Java内存模型中的 <strong>“store 和 write</strong> 操作。</p>
<p>所以通过这样一个空操作，可让前面 <strong>volatile</strong> 变量的修改对其他处理器立即可见。</p>
<blockquote>
<p>从硬件 架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。</p>
</blockquote>
<h3 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h3><h4 id="规则总结"><a href="#规则总结" class="headerlink" title="规则总结"></a>规则总结</h4><ol>
<li>在工作内存中，每次使用 <strong>volatile</strong> 变量前都必须从主内存刷新最新的值，用于保证能看见其他线程对变量所做的修改。</li>
<li>在工作内存中，每次修改使用 <strong>volatile</strong> 的变量后都必须立刻同步回主内存中，用于保证其他线程可以看见自己对变量做的修改。</li>
<li><strong>volatile</strong> 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。</li>
</ol>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>在某些情况下，<strong>volatile</strong> 的同步机制的性能确实要优于锁（使用 <strong>synchronized</strong> 关键字或 <code>java.util.concurrent</code> 包里的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说 <strong>volatile</strong> 就会比 <strong>synchronized</strong> 快上多少。</p>
<p><font color=red><strong>volatile  变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，不过即便如此，大多数场景下 volatile 的总开销仍然要比锁来的更低</strong>。</font></p>
<h2 id="5-针对-long-和-double-类型变量的特殊规则"><a href="#5-针对-long-和-double-类型变量的特殊规则" class="headerlink" title="5. 针对 long 和 double 类型变量的特殊规则"></a>5. 针对 long 和 double 类型变量的特殊规则</h2><h3 id="5-1-long-和-double-的非原子性协定"><a href="#5-1-long-和-double-的非原子性协定" class="headerlink" title="5.1 long 和 double 的非原子性协定"></a>5.1 long 和 double 的非原子性协定</h3><p>Java 内存模型要求 lock、unlock、read、load、assign、use、store、write 这八种操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义了一条宽松的规定：</p>
<p><strong>允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行</strong>。</p>
<p>即 <strong>允许虚拟机实现自行选择是否要保证 64 位数据类型的 load、store、read 和 write 这四个操作的原子性</strong>。</p>
<h3 id="5-2-小结"><a href="#5-2-小结" class="headerlink" title="5.2 小结"></a>5.2 小结</h3><p>如果有多个线程共享一个并未声明为 <strong>volatile</strong> 的 <strong>long</strong> 或 <strong>double</strong> 类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了 <strong>”半个变量“</strong> 的数值。</p>
<p>进过实际测试，在目前主流平台下商用的 64 位 Java 虚拟机中并不会出现非原子性访问行为，但是对于 32 位的Java虚拟机，譬如比较常用的 32 位 x86 平台下的 HotSpot 虚拟机，对 <strong>long</strong> 类型的数据确实存在非原子性访问的风险。</p>
<p>从 JDK9 起，HotSpot 虚拟机增加了一个实验性的参数 <code>-XX:+AlwaysAtomicAccesses</code> （这是 JEP 188 对 Java 内存模型更新的一部分内容）来约束虚拟机对所有数据类型进行原子性的访问。</p>
<p>而针对 <strong>double</strong> 类型，由于现代中央处理器中一般都包含专门用于处理浮点数据的浮点运算器（Floating Point unit，FPU），用来专门处理单、双精度的浮点数据，所以哪怕是 32 位虚拟机中通常也不会出现非原子性访问的问题。</p>
<p>在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的    long 和 double 变量专门声明为 volatile。</p>
<h2 id="6-原子性、可见性与有序性"><a href="#6-原子性、可见性与有序性" class="headerlink" title="6. 原子性、可见性与有序性"></a>6. 原子性、可见性与有序性</h2><p>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。</p>
<h3 id="6-1-原子性"><a href="#6-1-原子性" class="headerlink" title="6.1 原子性"></a>6.1 原子性</h3><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write 这六个。</p>
<p>我们大致可以认为，<strong>基本数据类型的访问、读写都是具备原子性的</strong> （例外就是 long 和 double 的非原子性协定，只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p>
<p>如果需要一个更大范围的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作来满足需求。</p>
<p>尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但却提供了更高层次的字节码指令 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 来隐式地使用这两个操作。</p>
<p>这两个字节码指令反映到 Java 代码中就是同步块 <strong>synchronized</strong> 关键字，因此在 <strong>synchronized</strong> 块之间的操作也具备了原子性。</p>
<h3 id="6-2-可见性"><a href="#6-2-可见性" class="headerlink" title="6.2 可见性"></a>6.2 可见性</h3><p>可见性就是指，当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p>
<p>Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。</p>
<p>普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<h4 id="（1）synchronized-实现可见性"><a href="#（1）synchronized-实现可见性" class="headerlink" title="（1）synchronized 实现可见性"></a>（1）synchronized 实现可见性</h4><p>同步块的可见性是由 <strong>”对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write操作）“</strong> 这条规则获得的。</p>
<h4 id="（2）final-关键字实现可见性"><a href="#（2）final-关键字实现可见性" class="headerlink" title="（2）final 关键字实现可见性"></a>（2）final 关键字实现可见性</h4><p>final 关键字的可见性是指：</p>
<p><strong>被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 “this” 的引用传递出去（this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问的 “初始化了一半” 的对象），那么在其他线程中就能看见 final 字段的值</strong>。</p>
<h3 id="6-3-有序性"><a href="#6-3-有序性" class="headerlink" title="6.3 有序性"></a>6.3 有序性</h3><p>Java 程序中天然的有序性可以总结为一句话：</p>
<p><strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</strong>。</p>
<p>前半句是指 <strong>“线程内似表现为串行的语义</strong>。</p>
<p>后半句是指 <strong>”指令重排序“ 现象和 ”工作内存与主内存同步延迟“ 现象</strong>。</p>
<h4 id="（1）volatile-实现有序性"><a href="#（1）volatile-实现有序性" class="headerlink" title="（1）volatile 实现有序性"></a>（1）volatile 实现有序性</h4><p>volatile 关键字本身就包含了禁止指令重排序的语义。</p>
<h4 id="（2）synchronized-实现有序性"><a href="#（2）synchronized-实现有序性" class="headerlink" title="（2）synchronized 实现有序性"></a>（2）synchronized 实现有序性</h4><p>synchronized 由 <strong>“一个变量在同一时刻只允许一条线程对其进行 lock 操作”</strong> 这条规则获得的，</p>
<p>这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<h2 id="7-先行发生原则"><a href="#7-先行发生原则" class="headerlink" title="7. 先行发生原则"></a>7. 先行发生原则</h2><h3 id="7-1-什么是先行发生原则"><a href="#7-1-什么是先行发生原则" class="headerlink" title="7.1 什么是先行发生原则"></a>7.1 什么是先行发生原则</h3><p>先行发生原则是 Java 内存模型中定义的两项操作之间的偏序关系。</p>
<p>比如果操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到。</p>
<p>“影响” 包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作在线程A中执行</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作在线程B中执行</span></span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作在线程C中执行</span></span><br><span class="line">i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-先行发生规则"><a href="#7-2-先行发生规则" class="headerlink" title="7.2 先行发生规则"></a>7.2 先行发生规则</h3><p>以下是 Java 内存模型下一些 “天然的” 先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。</p>
<p><strong>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意进行重排序</strong>。</p>
<ol>
<li><strong>程序次序规则：</strong> <strong>在一个线程内</strong>，按照控制流顺序，书写在前面的操作先行发生于写在后面的操作。注意，这里说的是 <strong>控制流顺序</strong> 而不是 <strong>程序代码顺序</strong> ，因为要考虑分支、循环等结构。</li>
<li><strong>管程锁定规则：</strong>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是 “同一个锁”，而 “后面” 是指时间上的先后。</li>
<li><strong>volatile 变量规则：</strong>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的 “后面” 同样是指时间上的先后。</li>
<li><strong>线程启动规则：</strong><code>Thread</code> 对象的 <code>start()</code> 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则：</strong>线程中的所有操作都先行发生于对此线程的终止检测。我们可以通过 <code>Thread::join</code> 方法是否结束、<code>Thread::isAlive()</code> 方法的返回值等手段检测线程是否已经终止执行。</li>
<li><strong>线程中断规则：</strong>对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断时间的发生。可以通过 <code>Thread::interrupted()</code> 方法检测到是否有中断发生。</li>
<li><strong>对象终结规则：</strong>一个对象的初始化完成（构造函数执行结束）先行发生于它的 <code>finalize()</code> 方法的开始。</li>
<li><strong>传递性：</strong>如果操作 A 先行发生于操作 B ，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</li>
</ol>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/posts/30991/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Redis 压缩列表ziplist</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/posts/53751/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">ReentrantLock 实现双线程顺序打印1-100</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">JD</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BD%9C%E7%94%A8"><span class="nav-text">1. Java内存模型作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-text">2. 主内存与工作内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%BB%E5%86%85%E5%AD%98"><span class="nav-text">2.1 主内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-text">2.2 工作内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-text">3. 内存间交互操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3.1 八种基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%85%AB%E7%A7%8D%E6%93%8D%E4%BD%9C%E5%BF%85%E9%A1%BB%E6%BB%A1%E8%B6%B3%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">3.2 八种操作必须满足的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B0%8F%E7%BB%93"><span class="nav-text">3.3 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-volatile-%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="nav-text">4. volatile 型变量的特殊规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-volatile-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="nav-text">4.1 volatile 修饰的变量两个特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BF%9D%E8%AF%81%E6%AD%A4%E5%8F%98%E9%87%8F%E5%AF%B9%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">（1）保证此变量对所有线程的可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="nav-text">（2）禁止指令重排序优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">如何实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%B0%8F%E7%BB%93"><span class="nav-text">4.2 小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="nav-text">规则总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-text">性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%92%88%E5%AF%B9-long-%E5%92%8C-double-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="nav-text">5. 针对 long 和 double 类型变量的特殊规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-long-%E5%92%8C-double-%E7%9A%84%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8D%8F%E5%AE%9A"><span class="nav-text">5.1 long 和 double 的非原子性协定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%B0%8F%E7%BB%93"><span class="nav-text">5.2 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-text">6. 原子性、可见性与有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">6.1 原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">6.2 可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89synchronized-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">（1）synchronized 实现可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89final-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">（2）final 关键字实现可见性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-text">6.3 有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89volatile-%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-text">（1）volatile 实现有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89synchronized-%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-text">（2）synchronized 实现有序性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="nav-text">7. 先行发生原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="nav-text">7.1 什么是先行发生原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E8%A7%84%E5%88%99"><span class="nav-text">7.2 先行发生规则</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
