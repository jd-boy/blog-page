<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="JD">
    
    <title>
        
            架构安全性 |
        
        Bean You
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.ico">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jzcupid.cn","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/favicon.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"莫听穿林打叶声，何妨吟啸且徐行。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Bean You
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">架构安全性</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">JD</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-03-29 10:47:40
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/">凤凰架构</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/HTTP/">HTTP</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>即使只限定在 “软件架构设计” 这个语境下，系统安全仍然是一个很大的话题。我们讨论的计算机系统安全，不仅仅是指 “防御系统被黑客攻击” 这样狭隘的安全，还至少应包括（不限于）以下这些问题的具体解决方案。</p>
<ul>
<li><strong>认证（Authentication）</strong>：系统如何正确分辨出操作用户的真实身份？</li>
<li><strong>授权（Authorization）</strong>：系统如何控制一个用户该看到哪些数据，操作哪些功能？</li>
<li><strong>凭证（Credential）</strong>：系统如何保证它与用户之间的承诺是双方当时真实意图的体现是准确、完整且不可抵赖的？</li>
<li><strong>保密（Confidentiality）</strong>：系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</li>
<li><strong>传输（Transport Security）</strong>：系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</li>
<li><strong>验证（Verification）</strong>：系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</li>
</ul>
<p>与安全相关的问题，一般不会直接创造价值，解决起来又烦琐复杂，费时费力，很容易被开发人员忽略，但庆幸的是这些问题基本上也都是与具体系统、具体业务无关的通用性问题，这意味着它们往往会存在业界通行的、已被验证过是行之有效的解决方案，甚至已经形成行业标准，不需要开发者自己从头去构思如何解决。</p>
<p>此外，还有其他一些与安全相关的内容主要是由管理、运维、审计领域为主导，尽管也需要软件架构和开发人员的配合参与，但不列人本章的讨论范围之内，譬如安全审计、系统备份与恢复、信息系统安全法规与制度计算机防病毒制度、保护私有信息规则等。</p>
<h2 id="一、认证"><a href="#一、认证" class="headerlink" title="一、认证"></a>一、认证</h2><p>认证、授权和凭证可以说是一个系统中最基础的安全设计，哪怕再简陋的信息系统大概也不可能忽略 “用户登录” 功能。信息系统为用户提供服务之前，总是希望先弄清楚 “你是谁”（认证）、“你能干什么”（授权）以及 “你如何证明”（凭证）这三个基本问题。然而，这三个基本问题又不像部分开发者认为的那样，只是一个 “系统登录” 功能，仅仅是校验一下用户名、密码是否正确这么简单。账户和权限作为一种必须最大限度保障安全和隐私，同时又要兼顾各个系统模块甚至系统间共享访问的基础主数据，它的存储、管理与使用都面临一系列复杂的问题。对于某些大规模的信息系统，账户和权限的管理往往要由专门的基础设施来负责，譬如微软的活动目录（Active Directory，AD）或者轻量目录访问协议（Lightweight Directory Access Protocol，LDAP），跨系统的共享使用甚至会用到区块链技术。</p>
<p>另外还有一个认知偏差：尽管 “认证” 是解决 “你是谁” 的问题，但这里的 “你” 并不一定是指人，也可能是指外部的代码，即第三方的类库或者服务。最初，对代码认证的重要程度甚至高于对最终用户的认证，譬如在早期的 Java 系统里，安全认证默认是特指 “代码级安全”，即你是否信任要在电脑中运行的代码。这是由 Java 当时的主要应用形式—— Java Applets 所决定的：类加载器从远端下载一段字节码，以 Applets 的形式在用户的浏览器中运行，由于Java操控计算机资源的能力要远远强于 JavaScript，因此必须先确保这些代码不会损害用户的计算机。这一阶段的安全观念催生了现在仍然存在于 Java 技术体系中的 “安全管理器”（java.lang.SecurityManager）、“代码权限许可”（java.lang.RuntimePermission）等概念。如今，对外部类库和服务的认证需求依然普遍，但相比起五花八门的最终用户认证来说，代码认证的研究方向已经很固定，基本上都统一到证书签名上。在本节中，认证的范围只限于对最终用户的认证，而代码认证会安排在后面9.2节中讲解。</p>
<h3 id="1-认证的标准"><a href="#1-认证的标准" class="headerlink" title="1. 认证的标准"></a>1. 认证的标准</h3><p>世纪之交，Java 迎来了 Web 的辉煌时代，互联网的迅速兴起促使 Java 进人快速发展时期。这时候，基于 HTML 和 JavaScript 的超文本Web 应用迅速超过了 “Java 2 时代” 之前的 Java Applets 应用，B/S 系统对最终用户认证的需求使得 “安全认证” 的重点逐渐从 “代码级安全” 转为 “用户级安全”，即你是否信任正在操作的用户。在1999年，随 J2EE 1.2 发布的 Servlet 2.2 中添加了一系列用于认证的 API，主要包括下列两部分内容：</p>
<ul>
<li>标准方面，添加了四种内置的、不可扩展的认证方案，即 Client-Cert、Basic、Digest 和 Form；</li>
<li>实现方面，添加了一套与认证和授权相关的程序接口，譬如 <code>HttpServletRequest::isUserInRole()</code>、<code>HttpServletRequest::getUserPrincipal()</code>等方法。</li>
</ul>
<p>一项发布超过20年的老旧技术，原木并没有什么专门提起的必要性，笔者之所以引用这件事，是希望从它包含的两部分内容中引出一个架构安全性的经验原则：以标准规范为指导、以标准接口去实现。安全涉及的问题很麻烦，但解决方案已相当成熟，对于99%的系统来说、在安全上不去做轮子，不去想发明创造，严格遵循标准，就是最恰当的安全设计。</p>
<p>引用 J2EE1.2 对安全的改进还有另一个原因，它内置的 Client-Cert、Basic、Digest 和 Form 这四种认证方案都很有代表性，刚好分别覆盖了通信信道、协议和内容层面的认证。而这三种层面的认证恰好涵盖了主流的三种认证方式，具体含义和应用场景列举如下。</p>
<ul>
<li><strong>通信信道上的认证</strong>：你和我建立通信连接之前，要先证明你是谁。在网络传输（Network）场景中的典型应用是基于 SSL/TLS 传输安全层的认证。</li>
<li><strong>通信协议上的认证</strong>：你请求获取我的资源之前，要先证明你是谁。在互联网（Internet）场景中的典型应用是基于 HTTP 协议的认证。</li>
<li><strong>通信内容上的认证</strong>：你使用我提供的服务之前，要先证明你是谁。在万维网（World Wide Web）场景中的典型应用是基于Web内容的认证。</li>
</ul>
<p>关于通信信道上的认证，由于内容较多，又与后续介绍微服务安全方面的话题密切相关，所以将独立放到5.5节介绍、而且J2EE中的Client-Cert 其实并不是用于TLS的，以它引出 TLS 并不合适。下面重点了解基于通信协议和通信内容的两种认证方式。</p>
<h4 id="1）HTTP-认证"><a href="#1）HTTP-认证" class="headerlink" title="1）HTTP 认证"></a>1）HTTP 认证</h4><p>前文已经提前用到了一个技术名词——认证方案（Authentication Scheme），它是指生成用户身份凭证的某种方法，这个概念最初源于  HTTP 协议的认证框架（Authentication Framework）。IETF 在 RFC 7235 中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，在未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时应在响应报文头里附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取何种方式产生能代表访问者身份的凭证信息：</p>
<blockquote>
<p>WWW-Authenticate：&lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</p>
<p>Proxy-Authenticate：&lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</p>
</blockquote>
<p>接收到该响应后，客户端必须遵循服务端指定的认证方案，在请求资源的报文头加入身份凭证信息，由服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden 错误。请求头报文应包含以下Header项之一：</p>
<blockquote>
<p>Authorization： &lt;认证方案&gt; &lt;凭证内容&gt;<br>Proxy-Authorization：&lt;认证方案&gt; &lt;凭证内容&gt;</p>
</blockquote>
<p>HTTP 认证框架提出认证方案是希望能把认证 “要产生身份凭证” 的目的与 “具体如何产生凭证” 的实现分离开来，无论客户端通过生物信息（指纹、人脸）、用户密码、数字证书抑或其他方式来生成凭证，都属于如何生成凭证的具体实现，都可以包含在HTTP协议预设的框架之内。HTTP认证框架的工作流程如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/HTTP%E8%AE%A4%E8%AF%81%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="HTTP认证框架的工作流程时序图"></p>
<p>以上概念性的介绍可能会有些枯燥抽象，下面笔者将以最基础的认证方案 “HTTP Basic 认证” 为例来介绍认证是如何工作的。HTTP Basic 认证是一种主要以演示为目的的认证方案，也应用于一些不要求安全性的场合，譬如家里的路由器登录等。Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码 “加密” 后作为身份凭证。譬如请求资源“GET/admin”后，浏览器会收到来自服务端的如下响应：</p>
<blockquote>
<p>HTTP/1.1 401 Unauthorized<br>Date:  Mon, 24 Feb 2020 16：50：53 GMT<br>WWW-Authenticate: Basic realm=”example from icyfenix.cn”</p>
</blockquote>
<p>此时，浏览器必须询问最终用户，即弹出如图所示的 HTTP Basic 认证对话框，要求提供用户名和密码。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/Http%20Basice%E8%AE%A4%E8%AF%81%E5%AF%B9%E8%AF%9D%E6%A1%86.pic.jpg" alt="Http Basice认证对话框"></p>
<p>用户在对话框中输入密码信息，譬如输入用户名 “icyfenix”，密码 “123456”，浏览器会将字符串 “icyfenix：123456” 编码为“aWN5ZmVuaXg6MTIzNDU2”，然后发送给服务端，HTTP 请求如下所示：</p>
<blockquote>
<p>GET /admin HTTP/1.1<br>Authorization： Basic aWN5zmVuaXg6MTIzNDU2</p>
</blockquote>
<p>服务端接收到请求，解码后检查用户名和密码是否合法，如果合法就返回 “/admin“的资源，否则就返回 403 Forbidden 错误，禁止下一步操作。注意 Base64 只是一种编码方式，并非任何形式的加密，所以 Basic 认证的风险是显而易见的。除 Basic 认证外，IETF 还定义了很多种可用于实际生产环境的认证方案，列举如下。</p>
<ul>
<li><strong>Digest</strong>：RFC 7616，HTTP摘要认证，可视为Basic认证的改良版本。针对Base64明文发送的风险，Digest认证把用户名和密码加盐（一个被称为 Nonce 的变化值作为盐值）后再通过MD5/SHA等哈希算法取摘要发送出去。但是这种认证方式依然是不安全的，无论客户端使用何种加密算法加密，无论是否采用了Nonce 这样的动态盐值去抵御重放和冒认，遇到中间人攻击时依然存在显著的安全风险。关于加解密的问题，将在后边详细讨论。</li>
<li><strong>Bearer</strong>：RFC 6750，基于 OAuth2 规范来完成认证。OAuth 2 是一个同时涉及认证与授权的协议，具体将在后边节详细介绍。</li>
<li><strong>HOBA（HTTP Origin-Bound Authentication）</strong>：RFC 7486，一种基于自签名证书的认证方案。基于数字证书的信任关系主要有两类模型：一类是采用 CA（Certification Authority，认证机构）层次结构的模型，由CA中心签发证书；另一种是以 IETF的 Token Binding 协议为基础的 OBC（Origin Bound Certificate，原产地证书）自签名证书模型。后边将详细介绍数字证书。</li>
</ul>
<p>HTTP认证框架中的认证方案是允许自行扩展的，并不要求一定由RFC规范来定义，只要用户代理（UserAgent，通常是浏览器、泛指任何使用HTTP协议的程序）能够识别种私有的认证方案即可。因此，很多厂商也扩展了自己的认证方案。</p>
<ul>
<li><strong>AWS4-HMAC-SHA256</strong>：亚马逊 AWS 基于 HMAC-SHA256 哈希算法的认证。</li>
<li><strong>NTLM / Negotiate</strong>：微软公司 NTLAN Manager（NTLM）用到的两种认证方式。</li>
<li><strong>Windows Live ID</strong>：微软公司开发并提供的 “统一登人” 认证。</li>
<li><strong>Twitter Basic</strong>：Twitter 改良的 HTTP 基础认证。</li>
</ul>
<h4 id="2）Web-认证"><a href="#2）Web-认证" class="headerlink" title="2）Web 认证"></a>2）Web 认证</h4><p>lETF 为 HTTP 认证框架设计了可插拔（Pluggable）的认证方案，原本是希望能涌现出各式各样的认证方案去支持不同的应用场景。尽管上节列举了一些还算常用的认证方案。但目前的信息系统，尤其是在系统对终端用户的认证场景中，直接采用 HTTP 认证框架的比例其实十分低。这不难理解，HTTP 是“超文本传输协议”，传输协议的根本职责是把资源从服务端传输到客户端，至于资源具体是什么内容，只能由客户端自行解析驱动。以 HTTP 协议为基础的认证框架也只能面向传输协议而不是具体传输内容来设计，如果用户想要从服务器中下载文件，弹出一个 HTTP 服务器的对话框，让用户登录是可接受的；但如果用户想访问信息系统中的具体服务，肯定希望身份认证是由系统本身的功能去完成，而不是由 HTTP 服务器来负责认证。这种依靠内容而不是传输协议来实现的认证方式，在万维网里被称为“Web认证”，由于实现形式上登录表单占了绝对的主流，因此通常也被称为<br>“表单认证”（Form Authentication）。</p>
<p>直至2019年以前，表单认证都没有什么行业标准可循，如表单是什么样，其中的用户字段、密码字段、验证码字段是否要在客户端加密，采用何种方式加密，接受表单的服务地址是什么，等等，都完全由服务端与客户端的开发者自行协商决定。“没有标准的约束”反倒成了表单认证的一大优点，它允许我们做出五花八门的页面，各种程序语言、框架或开发者本身都可以自行决定认证的全套交互细节。</p>
<p>可能你还记得开篇说的 “遵循规范、别造轮子就是最恰当的安全”，这里又将表单认证的高自由度说成是一大优点，好话都让笔者给说全了。笔者提倡用标准规范去解决安全领域的共性问题，这条原则完全没有必要与界面是否美观合理、操作流程是否灵活便捷这些应用需求对立起来。譬如，想要支持密码或扫码等多种登录方式、想要支持图形验证码来驱逐爬虫与机器人、想要支持在登录表单提交之前进行必要的表单校验，等等，这些需求十分具体，不具备写入标准规范的通用性，却具备足够的合理性，应当在实现层面去满足。同时，如何控制权限保证不产生越权操作、如何传输信息保证内容不被窃听篡改、如何加密敏感内容保证即使泄漏也不被逆推出明文，等等，这些问题已有通行的解决方案，并明确定义在规范之中，也应当在架构层面去遵循。</p>
<p>表单认证与 HTTP 认证不一定是完全对立的，两者有不同的关注点，可以结合使用。以 Fenix’s Bookstore 的登录功能为例，页面表单是一个自行设计的 Vue.js 页面。但认证的整个交互过程遵循 OAuth2 规范的密码模式。</p>
<p>2019年3月，万维网联盟（World Wide Web Consortium.w3C）批准了由 FIDO（Fast IDentity Online，一个安全、开放、防钓鱼、无密码认证标准的联盟）领导起草的世界首份 Web 内容认证的标准 “WebAuthn”，这里也许有读者会感到矛盾与奇怪，不是刚说了 Web 表单是什么样、要不要验证码、登录表单是否在客户端校验等是十分具体的需求，不太可能定义在规范上吗？确实如此，所以 WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以USB、蓝牙、NFC连接的物理密钥容器）来作为身份凭证，从根本上消灭了用户输入错误产生的校验需求和防止机器人模拟产生的验证码需求等问题，甚至可以省掉表单界面。</p>
<p>由于 WebAuthn 相对复杂，在阅读下面内容之前，如果你的设备和环境允许，建议务在 GitHub 网站的 2FA 认证功能中实际体验一下如何通过 WebAuthn 完成两段式登录，再继续阅读后面的内容。硬件方面，要求用带有 TouchID 的 MacBook，或者其他支持指纹 FacelD 验证的手机(目前在售的移动设备基本都带有生物识别装置)。软件方面，直至 ios13.6.iPhone 和 iPad 仍未支持 WebAuthn，但 Android 和 Mac OS系统中的 Chrome，以及 Windows 的 Edge 浏览器都已经支持使用 WebAuthn了。</p>
<p>WebAuthn 规范涵盖了“注册”与“认证”两大流程。先来介绍注册流程，它大致可以分为以下步骤。</p>
<ol>
<li>用户进入系统的注册页面，这个页面的格式、内容和用户注册时需要填写的信息均不包含在 WebAuthn 标准的定义范围内。</li>
<li>当用户填写完信息、点击提交注册信息的按钮后，服务端先暂存用户提交的数据，生成一个随机字符串（在规范中称作 Challenge）和用户的 UserID （在规范中称作凭证ID），并返回客户端。</li>
<li>客户端的 WebAuthnAPI 接收到 Challenge 和 UserID 后，把这些信息发送给验证器（Authenticator）。验证器可理解为用户设备上 TouchID、FaceID、实体密钥等认证设备的统一接口。</li>
<li>验证器提示用户进行验证。如果支持多种认证设备，还会提示用户选择一个想要使用的设备。验证的结果是生成一个密钥对（公钥和私钥），由验证器存储私钥、用户信息以及当前的域名。然后使用私钥对 Challenge 进行签名，并将签名结果、UserID 和公钥一起返回客户端。</li>
<li>浏览器将验证器返回的结果转发给服务器。</li>
<li>服务器核验信息，检查 UserID 与之前发送的是否一致，并用公钥解密后得到的结果与之前发送的 Challenge 作对比，一致即表明注册通过，由服务端存储该UserlD 对应的公钥。</li>
</ol>
<p><img src="http://qiniu.jzcupid.cn/blog/%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="注册流程时序图"></p>
<p>登录流程与注册流程类似，大致可以分为以下步骤。</p>
<ol>
<li>用户访问登录页面，填入用户名后即可点击登录按钮。</li>
<li>服务器返回随机字符串 Challenge、用户 UserID。</li>
<li>浏览器将 Challenge 和 UserID 转发给验证器。</li>
<li>验证器提示用户进行认证操作。由于在注册阶段验证器已经存储了该域名的私钥和户信息。所以如果域名和用户都相同的话，就不需要生成密钥对了，直接以存储的私钥加密 Challenge，然后返回浏览器。</li>
<li>服务端接收到浏览器转发来的被私钥加密的 Challenge，并以此前注册时存储的公钥进行解密，如果解密成功则宣告登录成功。</li>
</ol>
<p>WebAuthn 采用非对称加密的公钥、私钥替代传统的密码，这是非常理想的认证方案。钥是保密的，只有验证器需要知道它，连用户本人都不需要知道，也就没有人为泄漏的可能。公钥是公开的，可以被任何人看到或存储。公钥可用于验证私钥生成的签名，但不能用来签名，除了得知私钥外，没有其他途径能够生成可被公钥验证为有效的签名，这样服务器就可以通过公钥是否能够解密来判断最终用户的身份是否合法。</p>
<p>WebAuthn 还解决了传统密码在网络传输上的风险问题，后续5.4节我们会讲到无论密码是否在客户端进行加密以及如何加密，对防御中间人攻击来说都是没有意义的。更值得夸赞的是，WebAuthn为登录过程带来极大的便捷性，不仅注册和验证的用户体验十分优秀而且彻底避免了用户在一个网站上泄漏密码，所有使用相同密码的网站都受到攻击的问题这个优点使得用户无须再为每个网站想不同的密码。<br>当前的 WebAuthn 还很年轻，普及率暂时还很有限，但笔者相信几年之内它必定会发展成Web认证的主流方式，被大多数网站和系统所支持。</p>
<h3 id="2-认证的实现"><a href="#2-认证的实现" class="headerlink" title="2. 认证的实现"></a>2. 认证的实现</h3><p>了解了业界标准的认证规范以后，本节将简要介绍一下在 Java 技术体系内通常是如何实现安全认证的。Java 其实也有自己的认证规范，第一个系统性的 Java 认证规范发布于 Java 1.3时代，是由 Sun 公司提出的同时面向代码级安全和用户级安全的认证授权服务—— JAAS（Java Authentication and Authorization Service，Java 认证和授权服务，Java 1.3 时处于扩展包中，Java 1.4 时被纳人标准包）。尽管JAAS 已经考虑到最终用户的认证，但代码级安全在规范中仍然占更主要的地位。可能今天用过甚至听过 JAAS 的 Java 程序员已经不多了，但是这个规范提出了很多在今天仍然活跃于主流 Java 安全框架中的概念，譬如一般把用户存放在 “Principal” 之中、密码存放在 “Credentials” 之中、登录后从安全上下文 “Context” 中获取状态等常见的安全概念，都可以追溯到这一时期所定下的 API：</p>
<ul>
<li>LoginModule（javax.security.auth.spi.LoginModule）；</li>
<li>LoginContext（javax.security.auth.login.LoginContext）；</li>
<li>Subject（javax.security.auth.Subject）；</li>
<li>Principal（java.securityPrincipal）；</li>
<li>Credentials（javax.security.auth.Destroyable、javax.security.auth.Refreshable）。</li>
</ul>
<p>虽然 JAAS 开创了这些沿用至今的安全概念，但规范本身实质上并没有得到广泛应用笔者认为有两大原因。一方面是由于 JAAS 同时面向代码级和用户级的安全机制，使得它过度复杂化，难以推广。在这个问题上 Java 社区一直有做持续的增强和补救，譬如 Java EE6 中的JASPIC、Java EE8 中的 EE Security。</p>
<ul>
<li>JSR 115: Java Authorization Contract for Containers (JACC)。</li>
<li>JSR 196: Java Authentication Service Provider Interface for Containers (JASPIC)。</li>
<li>JSR 375: Java EE Security API (EE Security)。</li>
</ul>
<p>而另一方面。可能是更重要的一个原因，在21世纪的第一个十年里，以 “With EJB“ 为口号，以 WebSphere、JBoss 等为代表的 J2EE 容器环境，与以 “Without EJB” 为口号以 Spring、Hibernate 等为代表的轻量化开发框架产生了激烈的竞争，结果是后者获得了全面胜利。这个结果使得依赖容器安全的 JAAS 无法得到大多数人的认可。</p>
<p>在今时今日，实际活跃于 Java 安全领域的是两个私有的（私有的意思是不由 JSR 所规范的，即没有 java/javax.* 作为包名）的安全框架：Apache Shiro 和 Spring Security。</p>
<p>相较而言，Apache Shiro 更便捷易用，而 Spring Security 的功能则更复杂强大一些。无论是单体架构还是微服务架构的 Fenix’s Bookstore，笔者都选择了 Spring Security 作为安全框架，这个选择与功能、性能之类的考量没什么关系，就只是因为 SpringBoot、Spring Cloud 全家桶的缘故。这里不打算罗列代码来介绍 Apache Shiro 与 Spring Security 的具体使用方法。只从目标上看，两个安全框架提供的功能都很类似，大致包括以下四类。</p>
<ul>
<li>认证功能：以HTTP协议中定义的各种认证、表单等认证方式确认用户身份，这是本节的主要话题。</li>
<li>安全上下文：用户获得认证之后，要开放一些接口，让应用可以得知该用户的基本资料，拥有的权限、角色，等等。</li>
<li>授权功能：判断并控制认证后的用户对什么资源拥有哪些操作许可，这部分内容会放到下一节介绍。</li>
<li>密码的存储与验证：密码是 “烫手的山芋”，无论是存储、传输还是验证都应谨慎处理，这部分内容会放到第四节具体讨论。</li>
</ul>
<h2 id="二、授权"><a href="#二、授权" class="headerlink" title="二、授权"></a>二、授权</h2><p>授权这个概念通常伴随着认证、审计、账号一同出现，并称为 AAAA（Authentication Authorization、Audit、Account，也有一些领域把 Account 解释为计费的意思）。授权行为在程序中的应用非常广泛，给某个类或某个方法设置范围控制符（public、protected、private、&lt;Package&gt;）在本质上也是一种授权（访问控制）行为。而在安全领域中所说的权就更具体一些。通常涉及以下两个相对独立的问题。</p>
<ul>
<li><strong>确保授权的过程可靠</strong>：对于单一系统来说，授权的过程是比较容易控制的，以前多语境上提到授权。实质上讲的都是访问控制，但理论上两者是应该分开的。在涉及多方的系统中，授权过程则是一个比较困难却必须严肃对待的问题：如何既能让第三方系统访问到所需的资源，又能保证其不泄露用户的敏感数据呢？常用的多授权协议主要有 OAuth2 和 SAML2.0。</li>
<li><strong>确保授权的结果可控</strong>：授权的结果用于对程序功能或者资源的访问控制（Access Control），成理论体系的权限控制模型有很多，譬如自主访问控制（Discretionary Access Control，DAC）、强制访问控制（Mandatory Access Control，MAC）、基于属性的访问控制（Attribute-Based Access Control，ABAC），还有最为常用的基于角色的访问控制（Role-Based Access Control，RBAC）。</li>
</ul>
<p>由于篇幅原因，在这一节我们只介绍 Fenix’s Bookstore 的代码中直接使用到的，也是日常开发中最常用到的 RBAC 和 OAuth2 这两种访问控制和授权方案。</p>
<h3 id="1-RBAC"><a href="#1-RBAC" class="headerlink" title="1. RBAC"></a>1. RBAC</h3><p>所有的访问控制模型，实质上都是在解决同一个问题：“谁（User）拥有什么权限（Authority）去操作（Operation）哪些资源（Resource）。”</p>
<p>这个问题初看起来并不难，一种直观的解决方案就是在用户对象上设定一些权限，当用户使用资源时，检查是否有对应的操作权限即可。很多著名的安全框架，譬如 Spring Security 的访问控制本质上就是这么做的。不过，这种把权限直接关联在用户身上的简单设计，在复杂系统上确实会导致一些比较烦琐的问题。试想一下，如果某个系统涉及成百上千的资源，又有成千上万的用户，若要为每个用户访问每个资源都分配合适的权限，必定导致巨大的操作量和极高的出错概率，这也正是 RBAC 所关注的问题之一。</p>
<p>RBAC 模型在业界中有多种说法，其中以美国 George Mason 大学信息安全技术实验室提出的 RBAC96 模型最具系统性、得到了普遍的认可。为了避免对每一个用户设定权限，RBAC 将权限从用户身上剥离。改为绑定到 “角色”（Role）上，将权限控制变为对 “角拥有操作哪些资源的许可” 这个逻辑表达式的值是否为真的求解过程。RBAC 的主要元素的关系图如下。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/RBAC%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="RBAC主要元素关系图"></p>
<p>上图中出现了一个新的名词 “<strong>许可</strong>”。许可是抽象权限的具象化体现，权限在 RBAC 系统中的含义是 “允许何种<strong>操作</strong>作用于哪些<strong>资源</strong>之上” ，这句话的具体实例即为 “许可”。提出许可这个概念的目的其实与提出角色的目的是完全一致的，只是更为抽象。角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系譬如不同的数据都能够有增、删、改等操作，如果将数据与操作搅和在一起也会面临配置膨胀问题。这里举个更具体的例子帮助你理清众多名词之间的关系。譬如某个论文管理系统的 UserStory 中，与访问控制相关的 Backlog 可能会是这样描述的：</p>
<blockquote>
<p><strong>Backlog</strong><br>周同学（User）是某SCI杂志的审稿人（Role），职责之一是在系统中审核论文（Authority）。在审稿过程（Session）中，当他认为某篇论文（Resource）达到了可以公开发表的标准时，就会在后台点击通过按钮（Operation）来完成审核</p>
</blockquote>
<p>以上 Backlog 中 “给论文点击通过按钮” 就是一种许可，它是 “审核论文” 这项权限的具象化体现。</p>
<p>采用 RBAC 不仅是为了简化配置操作，还天然地满足了计算机安全中的 “最小特权原则” （Least Privilege）。在 RBAC 模型中，角色拥有许可的数量是根据完成该角色工作职责所需的最小权限来赋予的，最典型的例子是操作系统权限管理中的用户组，根据对不同角色的职责分工，如管理员（Administrator）、系统用户（System）、验证用户（Authenticated User）、普通用户（User）、来宾用户（Guest）等分配各自的权限，既保证用户能够正常工作。也避免用户出现越权操作的风险。当用户的职责发生变化时，在系统中就体现为它所隶属的角色被改变，譬如将 “普通用户角色” 改变 “管理员角色”，从而迅速让该用户具备管理员的多个细分权限，降低权限分配错误的风险。</p>
<p>RBAC 还允许对不同角色之间定义关联与约束关系，进一步强化它的抽象描述能力。如不同的角色之间可以有继承性，典型的是 RBAC-1 模型的角色权限继承关系。譬如描述开发经理应该和开发人员一样具有代码提交的权限，描述开发人员都应该和任何公司员工一样具有食堂就餐的权限，就可以直接将食堂就餐赋予到公司员工的角色上，把代码提交赋予到开发人员的角色上，再让开发人员的角色从公司员工派生，开发经理的角色从开发人员中派生。</p>
<p>不同角色之间也可以具有互斥性，典型的是 RBAC-2 模型的角色职责分离关系。互斥性要求权限被赋予角色时，或角色被赋予用户时应遵循的强制性职责分离规定。举个例子。角色的互斥约束可限制同一用户只能分配到一组互斥角色集合中至多一个角色，譬如不能让同一名员工既当会计，也当出纳，否则资金安全无法保证。角色的基数约束可限制某个用户拥有的最大角色数目，譬如不能让同一名员工包揽产品、设计、开发、测试角色，否则产品质量无法保证。</p>
<p>建立访问控制模型的基本目的是管理垂直权限和水平权限。垂直权限即功能权限，譬如前面提到的审稿编辑有通过审核的权限、开发经理有代码提交的权限、出纳有从账户报取资金的权限，这一类某个角色完成某项操作的许可，都可以直接翻译为功能权限。由于实际应用与权限模型具有高度对应关系，将权限从具体的应用中抽离出来，放到通用的模型中是相对容易的 Spring Security、Apache Shiro 等权限框架就是这样的抽象产物，大多数系统都能采用这些权限框架来管理功能权限。</p>
<p>与此相对，水平权限即数据权限，但管理起来要困难许多。譬如用户 A、B 都属于同一个角色。但它们各自在系统中产生的数据完全有可能是私有的，A 访问或删除了 B 的数据也照样属于越权。一般来说、数据权限是很难抽象与通用的，仅在角色层面控制并不能满足全部业务的需要，很多时候只能具体到用户，甚至要具体管理到发生数据的某一行、一列之上，因此数据权限基本只能由信息系统自主完成，并不存在能放之四海皆准的通用数据权限框架。</p>
<p>本书后面章节中的 “重要角色” —— Kubernetes 完全遵循了 RBAC 来进行服务访问控制，Fenix’s Bookstore 所使用的 Spring Security 也参考了（但并没有完全遵循）RBAC 来设计它的访问控制功能。在 Spring Security 的设计里，用户和角色都可以拥有权限，譬如在它的 HttpSecurity 接口就同时有 hasRole() 和 hasAuthority() 方法。Spring Security 的访问控制模型如图5-6所示，可与前面 RBAC 的关系图对比一下。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/SpringSecurity%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B.png" alt="SpringSecurity访问控制模型"></p>
<p>从实现角度来看，Spring Security 中的角色和权限的差异很小，它们完全共享同一套存储结构。唯一的差别仅是角色会在存储时自动带上“ROLE” 前缀罢了。但从使用角度来看，角色和权限的差异可以很大，用户可以自行决定系统中许可是只能对应到角色身上，还是可以让用户也拥有某些角色中没有的权限。这一点不符合 RBAC 的思想，但笔者个人认同这是一种创新而非破坏，在 Spring Security 的文档上说得很清楚：这取决于你自己何使用。</p>
<blockquote>
<p> 角色和权限的核心差异取决于用户打算如何使用这些特性，在框架层面它们的差别是极小的，基本采用了完全相同的方式来进行处理</p>
</blockquote>
<p>通过 RBAC 很容易控制最终用户在广义和精细级别上能够做什么，可以指定用户是管理员、专家用户抑或普通用户，并使角色和访问权限与组织中员工的身份职位保持一致，仅根据需要为员工完成工作的最低限度来分配权限。这些都是大量软件系统、长时间积累下来的经验，将这些经验运用在软件产品上，绝大多数情况下要比自己发明、创造一个新的轮子更加安全。</p>
<h3 id="2-OAuth2"><a href="#2-OAuth2" class="headerlink" title="2. OAuth2"></a>2. OAuth2</h3><p>了解过 RBAC 的内容后，下面我们再来看看相对更复杂烦琐的 OAuth2 认证授权协议（更烦琐的 OAuth1 已经完全被废弃了）。OAuth2 是在<a class="link"   target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6749" >RFC 6749<i class="fas fa-external-link-alt"></i></a>中定义的国际标准，在 RFC 6749 正文的第一句就阐明了 OAuth2 是<strong>面向于解决第三方应用</strong>（Third-Party Application）的认证授权协议。如果你的系统并不涉及第三方，譬如我们单体架构的 Fenix’s Bookstore 中就既不为第三方提供服务，也不使用第三方的服务，那引入 OAuth2 其实并无必要。为什么强调第三方？在多方系统授权过程具体会有什么问题需要专门制订一个标准协议来解决呢？笔者举个现实的例子来解释。</p>
<p>譬如你现在正在阅读的这个网站（<a class="link"   target="_blank" rel="noopener" href="https://icyfenix.cn/" >https://icyfenix.cn<i class="fas fa-external-link-alt"></i></a>），它的建设和更新大致流程是：笔者以 Markdown 形式写好了某篇文章，上传到由<a class="link"   target="_blank" rel="noopener" href="https://github.com/fenixsoft/awesome-fenix" >GitHub 提供的代码仓库<i class="fas fa-external-link-alt"></i></a>，接着由<a class="link"   target="_blank" rel="noopener" href="https://travis-ci.com/" >Travis-CI<i class="fas fa-external-link-alt"></i></a>提供的持续集成服务会检测到该仓库发生了变化，触发一次 Vuepress 编译活动，生成目录和静态的 HTML 页面，然后推送回<a class="link"   target="_blank" rel="noopener" href="https://pages.github.com/" >GitHub Pages<i class="fas fa-external-link-alt"></i></a>，再触发国内的 CDN 缓存刷新。这个过程要能顺利进行，就存在一系列必须解决的授权问题，Travis-CI 只有得到了我的明确授权，GitHub 才能同意它读取我代码仓库中的内容，问题是它该如何获得我的授权呢？一种最简单粗暴的方案是把我的用户账号和密码都告诉 Travis-CI，但这显然导致了以下这些问题：</p>
<ul>
<li><strong>密码泄漏</strong>：如果 Travis-CI 被黑客攻破，将导致我的 GitHub 的密码也同时被泄漏。</li>
<li><strong>访问范围</strong>：Travis-CI 将有能力读取、修改、删除、更新我放在 GitHub 上的所有代码仓库，而我并不希望它能够修改删除文件。</li>
<li><strong>授权回收</strong>：只有修改密码才能回收我授予给 Travis-CI 的权力，可是我在 GitHub 的密码只有一个，授权的应用除了 Travis-CI 之外却还有许多，修改了意味着所有别的第三方的应用程序会全部失效。</li>
</ul>
<p>以上列举的这些问题，也正是 OAuth2 所要解决的问题，尤其是要求第三方系统没有支持 HTTPS 传输安全的环境下依然能够解决这些问题，这并非易事。</p>
<p>OAuth2 给出了多种解决办法，这些办法的共同特征是以令牌（Token）代替用户密码作为授权的凭证。有了令牌之后，哪怕令牌被泄漏，也不会导致密码的泄漏；令牌上可以设定访问资源的范围以及时效性；每个应用都持有独立的令牌，哪个失效都不会波及其他。这样上面提出的三个问题就都解决了。有了一层令牌之后，整个授权的流程如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E5%8A%A0%E4%BB%A4%E7%89%8C%E5%90%8E%E7%9A%84%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="加令牌后的授权流程示意图"></p>
<p>这个时序图里面涉及到了 OAuth2 中几个关键术语，我们通过前面那个具体的上下文语境来解释其含义，这对理解后续几种认证流程十分重要：</p>
<ul>
<li><strong>第三方应用</strong>（Third-Party Application）：需要得到授权访问我资源的那个应用，即此场景中的“Travis-CI”。</li>
<li><strong>授权服务器</strong>（Authorization Server）：能够根据我的意愿提供授权（授权之前肯定已经进行了必要的认证过程，但它与授权可以没有直接关系）的服务器，即此场景中的“GitHub”。</li>
<li><strong>资源服务器</strong>（Resource Server）：能够提供第三方应用所需资源的服务器，它与认证服务可以是相同的服务器，也可以是不同的服务器，此场景中的“我的代码仓库”。</li>
<li><strong>资源所有者</strong>（Resource Owner）： 拥有授权权限的人，即此场景中的“我”。</li>
<li><strong>操作代理</strong>（User Agent）：指用户用来访问服务器的工具，对于人类用户来说，这个通常是指浏览器，但在微服务中一个服务经常会作为另一个服务的用户，此时指的可能就是 HttpClient、RPCClient 或者其他访问途径。</li>
</ul>
<p>“用令牌代替密码”确实是解决问题的好方法，但这充其量只能算个思路，距离可实施的步骤还是不够具体的，时序图中的“要求/同意授权”、“要求/同意发放令牌”、“要求/同意开放资源”几个服务请求、响应该如何设计，这就是执行步骤的关键了。对此，OAuth2 一共提出了四种不同的授权方式（这也是 OAuth2 复杂烦琐的主要原因），分别为：</p>
<ul>
<li>授权码模式（Authorization Code）</li>
<li>隐式授权模式（Implicit）</li>
<li>密码模式（Resource Owner Password Credentials）</li>
<li>客户端模式（Client Credentials）</li>
</ul>
<h4 id="1）授权码模式"><a href="#1）授权码模式" class="headerlink" title="1）授权码模式"></a>1）授权码模式</h4><p>授权码模式是四种模式中最严（luō）谨（suō）的，它考虑到了几乎所有敏感信息泄漏的预防和后果。具体步骤的时序如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="授权码模式的调用时序图"></p>
<p>开始进行授权过程以前，第三方应用先要到授权服务器上进行注册，所谓注册，是指向认证服务器提供一个域名地址，然后从授权服务器中获取 ClientID 和 ClientSecret，以便能够顺利完成如下授权过程：</p>
<ol>
<li>第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI，这是一次客户端页面转向。</li>
<li>授权服务器根据 ClientID 确认第三方应用的身份，用户在授权服务器中决定是否同意向该身份的应用进行授权，用户认证的过程未定义在此步骤中，在此之前应该已经完成。</li>
<li>如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数，这是第二次客户端页面转向。</li>
<li>第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。该服务器的地址应与注册时提供的域名处于同一个域中。</li>
<li>授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。令牌可以是一个或者两个，其中必定要有的是访问令牌（Access Token），可选的是刷新令牌（Refresh Token）。访问令牌用于到资源服务器获取资源，有效期较短，刷新令牌用于在访问令牌失效后重新获取，有效期较长。</li>
<li>资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。</li>
</ol>
<p>这个过程设计，已经考虑到了几乎所有合理的意外情况，笔者再举几个最容易遇到的意外状况，以便你能够更好地理解为何要这样设计 OAuth2。</p>
<ul>
<li>会不会有其他应用冒充第三方应用骗取授权？<br>ClientID 代表一个第三方应用的“用户名”，这项信息是可以完全公开的。但 ClientSecret 应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第 5 步发放令牌时，调用者必须能够提供 ClientSecret 才能成功完成。只要第三方应用妥善保管好 ClientSecret，就没有人能够冒充它。</li>
<li>为什么要先发放授权码，再用授权码换令牌？<br>这是因为客户端转向（通常就是一次 HTTP 302 重定向）对于用户是可见的，换而言之，授权码可能会暴露给用户以及用户机器上的其他程序，但由于用户并没有 ClientSecret，光有授权码也是无法换取到令牌的，所以避免了令牌在传输转向过程中被泄漏的风险。</li>
<li>为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？<br>这是为了缓解 OAuth2 在实际应用中的一个主要缺陷，通常访问令牌一旦发放，除非超过了令牌中的有效期，否则很难（需要付出较大代价）有其他方式让它失效，所以访问令牌的时效性一般设计的比较短，譬如几个小时，如果还需要继续用，那就定期用刷新令牌去更新，授权服务器就可以在更新过程中决定是否还要继续给予授权。至于为什么说很难让它失效，我们将放到下一节“<a class="link"   target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials.html" >凭证<i class="fas fa-external-link-alt"></i></a>”中去解释。</li>
</ul>
<p>尽管授权码模式是严谨的，但是它并不够好用，这不仅仅体现在它那繁复的调用过程上，还体现在它对第三方应用提出了一个“貌似不难”的要求：第三方应用必须有应用服务器，因为第 4 步要发起服务端转向，而且要求服务端的地址必须与注册时提供的地址在同一个域内。不要觉得要求一个系统要有应用服务器是天经地义理所当然的事情，你现在阅读文章的这个网站就没有任何应用服务器的支持，里面使用到了 Gitalk 作为每篇文章的留言板，它对 GitHub 来说照样是第三方应用，需要 OAuth2 授权来解决。除基于浏览器的应用外，现在越来越普遍的是移动或桌面端的客户端 Web 应用（Client-Side Web Applications），譬如现在大量的基于 Cordova、Electron、Node-Webkit.js 的<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Progressive_web_application" >PWA 应用<i class="fas fa-external-link-alt"></i></a>，它们都没有应用服务器的支持。由于有这样的实际需求，因此引出了 OAuth2 的第二种授权模式：隐式授权。</p>
<h4 id="2）隐式授权模式"><a href="#2）隐式授权模式" class="headerlink" title="2）隐式授权模式"></a>2）隐式授权模式</h4><p>隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端支持，一步到位。代价是在隐式授权中，授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了，ClientSecret 没有人保管，就没有存在的意义了。但其实还是会限制第三方应用的回调 URI 地址必须与注册时提供的域名一致，尽管有可能被 DNS 污染之类的攻击所攻破，但仍算是尽可能努力一下。同样的原因，也不能避免令牌暴露给资源所有者，不能避免用户机器上可能意图不轨的其他程序、HTTP 的中间人攻击等风险了。</p>
<p>隐式授权的调用时序如下图（从此之后的授权模式，时序中笔者就不再画出资源访问部分的内容了，就是前面 opt 框中的那一部分，以便更聚焦重点）所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E9%9A%90%E5%BC%8F%E6%8E%88%E6%9D%83%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="隐式授权的调用时序图"></p>
<p>在时序图所示的交互过程里，隐式模式与授权码模式的显著区别是授权服务器在得到用户授权后，直接返回了访问令牌，这显著地降低了安全性，但 OAuth2 仍然努力尽可能地做到相对安全，譬如在前面提到的隐式授权中，尽管不需要用到服务端，但仍然需要在注册时提供回调域名，此时会要求该域名与接受令牌的服务处于同一个域内。此外，同样基于安全考虑，在隐式模式中明确禁止发放刷新令牌。</p>
<p>还有一点，在 RFC 6749 对隐式授权的描述中，特别强调了令牌必须是“通过 Fragment 带回”的。部分对超文本协议没有了解的读者，可能还根本不知道<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/URI_fragment" >Fragment<i class="fas fa-external-link-alt"></i></a>是个什么东西？</p>
<blockquote>
<p> 额外知识：Fragment</p>
<p>In computer hypertext, a fragment identifier is a string of characters that refers to a resource that is subordinate to another, primary resource. The primary resource is identified by a Uniform Resource Identifier (URI), and the fragment identifier points to the subordinate resource.</p>
<p>​                                                                                                                                                                        ——<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/URI_fragment" >URI Fragment<i class="fas fa-external-link-alt"></i></a>，Wikipedia</p>
</blockquote>
<p>看了这段英文定义还是觉得概念不好的话，我简单告诉你，Fragment 就是地址中<code>#</code>号后面的部分，譬如这个地址：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://bookstore.icyfenix.cn/<span class="params">#</span>/detail/1</span><br></pre></td></tr></table></figure>

<p>后面的<code>/detail/1</code>便是 Fragment，这个语法是在<a class="link"   target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3986" >RFC 3986<i class="fas fa-external-link-alt"></i></a>中定义的，RFC 3986 中解释了 Fragment 是用于客户端定位的 URI 从属资源，譬如 HTML 中就可以使用 Fragment 来做文档内的跳转而不会发起服务端请求，你现在可以点击一下这篇文章左边菜单中的几个子标题，看看浏览器地址栏的变化。此外，RFC 3986 还规定了如果浏览器对一个带有 Fragment 的地址发出 Ajax 请求，那 Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。所以隐式授权巧妙地利用这个特性，尽最大努力地避免了令牌从操作代理到第三方服务之间的链路存在被攻击而泄漏出去的可能性。至于认证服务器到操作代理之间的这一段链路的安全，则只能通过 TLS（即 HTTPS）来保证中间不会受到攻击了，我们可以要求认证服务器必须都是启用 HTTPS 的，但无法要求第三方应用同样都支持 HTTPS。</p>
<h4 id="3）密码模式"><a href="#3）密码模式" class="headerlink" title="3）密码模式"></a>3）密码模式</h4><p>前面所说的授权码模式和隐私模式属于纯粹的授权模式，它们与认证没有直接的联系，如何认证用户的真实身份是与进行授权互相独立的过程。但在密码模式里，认证和授权就被整合成了同一个过程了。</p>
<p>密码模式原本的设计意图是仅限于用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。这种高度可信的第三方是极为较罕见的，尽管介绍 OAuth2 的材料中，经常举的例子是“操作系统作为第三方应用向授权服务器申请资源”，但真实应用中极少遇到这样的情况，合理性依然十分有限。</p>
<p>笔者认为，如果要采用密码模式，那“第三方”属性就必须弱化，把“第三方”视作是系统中与授权服务器相对独立的子模块，在物理上独立于授权服务器部署，但是在逻辑上与授权服务器仍同属一个系统，这样将认证和授权一并完成的密码模式才会有合理的应用场景。</p>
<p>譬如 Fenix’s Bookstore 便直接采用了密码模式，将认证和授权统一到一个过程中完成，尽管 Fenix’s Bookstore 中的 Frontend 工程和 Account 工程都能直接接触到用户名和密码，但它们事实上都是整个系统的一部分，这个前提下密码模式才具有可用性。关于分布式系统各个服务之间的信任关系，后续会在“<a class="link"   target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/secure/zero-trust.html" >零信任网络<i class="fas fa-external-link-alt"></i></a>”与“<a class="link"   target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/secure/service-security.html" >服务安全<i class="fas fa-external-link-alt"></i></a>”中作进一步讨论。</p>
<p>理解了密码模式的用途，它的调用过程就很简单了，就是第三方应用拿着用户名和密码向授权服务器换令牌而已。具体时序如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="密码模式的调用时序图"></p>
<p>密码模式下“如何保障安全”的职责无法由 OAuth2 来承担，只能由用户和第三方应用来自行保障，尽管 OAuth2 在规范中强调到“此模式下，第三方应用不得保存用户的密码”，但这并没有任何技术上的约束力。</p>
<h4 id="4）客户端模式"><a href="#4）客户端模式" class="headerlink" title="4）客户端模式"></a>4）客户端模式</h4><p>客户端模式是四种模式中最简单的，它只涉及到两个主体，第三方应用和授权服务器。如果严谨一点，现在称“第三方应用”其实已经不合适了，因为已经没有了“第二方”的存在，资源所有者、操作代理在客户端模式中都是不必出现的。甚至严格来说叫“授权”都已不太恰当，资源所有者都没有了，也就不会有谁授予谁权限的过程。</p>
<p>客户端模式是指第三方应用（行文一致考虑，还是继续沿用这个称呼）以自己的名义，向授权服务器申请资源许可。此模式通常用于管理操作或者自动处理类型的场景中。举个具体例子，譬如笔者开了一家叫 Fenix’s Bookstore 的书店，因为小本经营，不像京东那样全国多个仓库可以调货，因此必须保证只要客户成功购买，书店就必须有货可发，不允许超卖。但经常有顾客下了订单又拖着不付款，导致部分货物处于冻结状态。所以 Fenix’s Bookstore 中有一个订单清理的定时服务，自动清理超过两分钟还未付款的订单。在这个场景里，订单肯定是属于下单用户自己的资源，如果把订单清理服务看作一个独立的第三方应用的话，它是不可能向下单用户去申请授权来删掉订单的，而应该直接以自己的名义向授权服务器申请一个能清理所有用户订单的授权。客户端模式的时序如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="客户端模式的调用时序图"></p>
<p>微服务架构并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间调用也需要先进行认证授权，然后才能通信。此时，客户端模式便是一种常用的服务间认证授权的解决方案。<a class="link"   target="_blank" rel="noopener" href="http://icyfenix.cn/exploration/projects/microservice_arch_springcloud.html" >Spring Cloud 版本的 Fenix’s Bookstore<i class="fas fa-external-link-alt"></i></a>是采用这种方案来保证微服务之间的合法调用的，<a class="link"   target="_blank" rel="noopener" href="http://icyfenix.cn/exploration/projects/servicemesh_arch_istio.html" >Istio 版本的 Fenix’s Bookstore<i class="fas fa-external-link-alt"></i></a>则启用了双向 mTLS 通信，使用客户端证书来保障安全，它们可作为上一节介绍认证时提到的“通信信道认证”和“通信内容认证”例子，感兴趣的读者可以对比一下这两种方式的差异优劣。</p>
<p>OAuth2 中还有一种与客户端模式类似的授权模式，在<a class="link"   target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8628#section-3.4" >RFC 8628<i class="fas fa-external-link-alt"></i></a>中定义为“设备码模式”（Device Code），这里顺带提一下。设备码模式用于在无输入的情况下区分设备是否被许可使用，典型的应用便是手机锁网解锁（锁网在国内较少，但在国外很常见）或者设备激活（譬如某游戏机注册到某个游戏平台）的过程。它的时序如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/%E8%AE%BE%E5%A4%87%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="设备码模式的调用时序图"></p>
<p>进行验证时，设备需要从授权服务器获取一个 URI 地址和一个用户码，然后需要用户手动或设备自动地到验证 URI 中输入用户码。在这个过程中，设备会一直循环，尝试去获取令牌，直到拿到令牌或者用户码过期为止。</p>
<h2 id="三、凭证"><a href="#三、凭证" class="headerlink" title="三、凭证"></a>三、凭证</h2><p>在前面介绍 OAuth2 的内容中，每一种授权模式的最终目标都是拿到访间令牌，但未涉及过拿回来的令牌应该长什么样子。反而还挖了一些坑没有填（为何说 OAuth2 的一个主要缺陷是令牌难以主动失效）。这节讨论的主角是令牌，同时，还会讨论如果不使用 OAuth2，如何以最传统的方式完成认证、授权。</p>
<p>对 “如何承载认证授权信息” 这个问题的不同看法，代表了软件架构对待共享状态信息的两种不同思路：状态应该维护在服务端，还是在客户端之中？在分布式系统崛起以前，这个问题原本已有了较为统一的结论，即以 HTTP 协议的 Cookie-Session 机制为代表的服务端状态存储在分布式崛起前的三十年中都是主流的解决方案。不过，到了最近十年，由于分布式系统中共享数据必然会受到 CAP 不兼容原理的打击限制，迫使人们重新去审视之前已基本放弃掉的客户端状态存储、这就让原本只在多方系统中采用的 JWT 令牌方案，在分布式系统中也有了另一块用武之地。本节将围绕 Cookie-Session 和 JWT 之间的相同与不同而展开。</p>
<h3 id="1-Cookie-Session"><a href="#1-Cookie-Session" class="headerlink" title="1. Cookie-Session"></a>1. Cookie-Session</h3><p>大家知道HTTP协议是一种无状态的传输协议，无状态是指协议对事务处理没有上下文的记忆能力，每一个请求都是完全独立的，但是我们中肯定有许多人并没有意识到 HTTP 协议无状态的重要性。假如你做了一个简单的网页，其中包含1 个 HTML、2 个Script脚本、3个CSS，还有 10 张图片，若要这个网页成功展示在用户屏幕前，需要完成 16 次与服务端的交互来获取上述资源，由于网络传输等各种因素的影响，服务器发送的顺序与客户端请求的先后并没有必然的联系，按照可能出现的响应顺序，理论上最多会有 P(16，16)＝20922789888000 种可能性。试想一下，如果 HTTP 协议不是设计成无状态的，这 16 次请求每一次都有依赖关联，先调用哪一个、先返回哪一个，都会对结果产生影响的话，那协调工作会多么复杂。</p>
<p>可是，HTTP 协议的无状态特性又有悖于我们最常见的网络应用场景，典型就是认证授权，系统总得要获知用户身份才能提供合适的服务，因此，我们也希望 HTTP 能有一种手段，让服务器至少能够区分出发送请求的用户是谁。为了实现这个目的，RFC6265规范<br>定义了HTTP的状态管理机制，在 HTTP 协议中增加了 Set-Cookie 指令，该指令的含义是以键值对的方式向客户端发送一组信息，此信息将在此后一段时间内的每次 HTTP 请求中，以名为 Cookie 的 Header 附带着重新发给服务端，以便服务端区分来自不同客户端的请求。一个典型的 Set-Cookie 指令如下所示：</p>
<blockquote>
<p>Set-Cookie:id＝icyfenix；Expires＝Wed，21 Feb 2020 07:28:00 GMT；Secure；Httponly</p>
</blockquote>
<p>收到该指令以后，客户端再对同一个域的请求回传时就会自动附带键值对信息 “id＝icyfenix”，譬如以下代码所示：</p>
<blockquote>
<p>GET /index.html HTTP/2.0<br>Host: icyfenix.cn<br>Cookie: id＝icyfenix</p>
</blockquote>
<p>根据每次请求传到服务端的 Cookie，服务端就能分辨出请求来自于哪一个用户。由于 Cookie 是放在请求头上的，属于额外的传输负担，不应该携带过多的内容，而且放在 Cookie 中传输并不安全，容易被中间人窃取或被篡改，所以通常不会设置例子中 “id＝icyfenix” 这样的明文信息。一般来说，系统会把状态信息保存在服务端，在 Cookie 里只传输一个无字面意义的、不重复的字符串，习惯上以 sessionid 或者 jsessionid 为名，然后服务端会把这个字符串作为Key，以 Key/Entity 的结构存储每一个在线用户的上下文状态，再辅以一些超时自动清理之类的管理措施。这种服务端的状态管理机制就是今天大家非常熟悉的 Session，Cookie-Session 也即最传统但今天依然广泛应用于大量系统中的，由服务端与客户端联动来完成的状态管理机制。</p>
<p>Cookie-Session 方案在本章的主题 “安全性” 上其实是有一定先天优势的：状态信息都存储于服务端，只要依靠客户端的同源策略和HTTPS 的传输层安全，保证 Cookie 中的键值不被窃取而出现被冒认身份的情况，就能完全规避掉信息在传输过程中被泄漏和篡改的<br>风险。Cookie-Session 方案的另一大优点是服务端有主动的状态管理能力，可根据自己的意愿随时修改、清除任意上下文信息，臂如很轻易就能实现强制某用户下线的功能。</p>
<p>Session-Cookie 在单节点的单体服务环境中是最合适的方案，但当需要水平扩展服务能力，要部署集群时就比较麻烦了，由于 Session 存储在服务器的内存中，当服务器水平拓展成多节点时，设计者必须在以下三种方案中选择其一。</p>
<ul>
<li><strong>牺牲集群的一致性</strong>，让负载均衡器采用亲和式的负载均衡算法，臂如根据用户 IP 或者 Session 来分配节点，每一个特定用户发出的所有请求都一直被分配到其中某个节点来提供服务，每个节点都不重复地保存着一部分用户的状态，如果这个节点崩溃了，里面的用户状态便完全丢失。</li>
<li><strong>牺牲集群的可用性</strong>，让各个节点之间采用复制式的 Session，每一个节点中的 Session 变动都会发送到组播地址的其他服务器上，这样即使某个节点崩溃了，也不会中断某个用户的服务，但 Session 之间组播复制的同步代价高昂，节点越多时，同步成本越高。</li>
<li><strong>牺牲集群的分区容忍性</strong>，让普通的服务节点中不再保留状态，将上下文集中放在个所有服务节点都能访问到的数据节点中进行存储。此时的矛盾是数据节点成为单点，一旦数据节点损坏或出现网络分区，整个集群将都不能再提供服务。</li>
</ul>
<p>通过前面章节的内容，我们已经知道<strong>只要在分布式系统中共享信息，CAP 就不可兼得所以分布式环境中的状态管理一定会受到 CAP 的限制，无论怎样都不可能完美</strong>。但如果只是解决分布式下的认证授权问题，并顺带解决少量状态的问题，就不一定只能依靠共享信息去实现。这句话的言外之意是提醒读者，接下来的 JWT 令牌与 Cookie-Session 并不是完全对等的解决方案，JWT 令牌只用来处理认证授权问题，充其量只能携带少量非敏感的信息，是 Cookie-Session 在认证授权问题上的替代品，而不能说 JWT 要比 Cookie-Session 更先进，更不可能说 JWT 可以全面取代 Cookie-Session 机制。</p>
<h3 id="2-JWT"><a href="#2-JWT" class="headerlink" title="2. JWT"></a>2. JWT</h3><p>Cookie-Session 机制在分布式环境下会遇到 CAP 不可兼得的问题，而在多方系统中，就更不可能谈 Session 层面的数据共享了，哪怕服务端之间能共享数据，客户端的 Cookie 也没法跨域。所以我们不得不重新捡起最初被抛弃的思路，当服务器存在多个，客户端只有一个时，把状态信息存储在客户端，每次随着请求发回服务器去。前面说过，这样做的缺点是无法携带大量信息，而且有泄漏和篡改的安全风险。信息量受限的问题并没有太好的解决办法，不过要确保信息不被中间人篡改则还是可以实现的，JWT 便是这个问题的标准答案。</p>
<p>JWT（JSON Web Token）定义于 RFC7519 标准之中，是目前广泛使用的一种令牌格式尤其经常与 OAuth2 配合应用于分布式的、涉及多方的应用系统中。介绍JWT的具体构成之前，我们先来直观地看一下它是什么样子的，如下图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/JWT%E4%BB%A4%E7%89%8C%E7%BB%93%E6%9E%84.png" alt="JWT令牌结构"></p>
<p>以上截图来自 <a class="link"   target="_blank" rel="noopener" href="https://jwt.io/" >JWT 官网<i class="fas fa-external-link-alt"></i></a>，数据则是笔者随意编的。右边的 JSON 结构是 JWT 令牌中携带的信息，左边的字符串呈现了 JWT 令牌的本体。它最常见的使用方式是附在名为 Authorization 的 Header 发送给服务端，前缀在 RFC6750 中被规定为 Bearere。如果你没有忘记 “认证方案” 与 “OAuth2” 的内容，那看到 Authorization 这个Header 与 Bearer 这个前缀时，便应意识到它是 HTTP 认证框架中的 OAuth2 认证方案。如下代码展示了一次采用 JWT 令牌的 HTTP 实际请求：</p>
<blockquote>
<p>GET /restful/products/1 HTTP/1.1<br>Host: 1cyfenix.cn<br>Connection: keep-alive<br>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</p>
</blockquote>
<p>上图中右边的状态信息是对令牌使用 Bas64URL 转码后得到的明文，请特别注意是明文，<strong>JWT 只解决篡改的问题，并不解决泄漏的问题</strong>，因此令牌默认是不加密的。尽管你自己要加密也不难做到，接收时自行解密即可，但这样做其实没有太大意义，具体原因将在第四节中阐述。</p>
<p>从明文中可以看到 JWT 令牌是以 JSON 结构（毕竟名字就叫 JSON Web Token）存储的，该结构总体上可划分为三个部分，每个部分间用点号 “.” 分隔开。第一部分是令牌头（Header），内容如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;a1g&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它描述了令牌的类型（统一为typ:JWT）以及令牌签名的算法，示例中 HS256 为 HMAC SHA256算法的缩写，其他各种系统支持的签名算法则可以参考JWT官网。</p>
<blockquote>
<p><strong>散列消息认证码</strong><br>在本节及后面其他关于安全的内容中，经常会在某种哈希算法前出现 “HMAC” 的前缀，这是指散列消息认证码（Hash-based Message Authentication Code，HMAC）。可以简单将它理解为一种带有密钥的哈希摘要算法，其实现形式上通常是把密钥以加盐方式混入，与内容一起做哈希摘要。</p>
<p>HMAC 哈希与普通哈希算法的差别是普通的哈希算法通过 Hash 函数结果易变性保证了原有内容未被篡改，而 HMAC 不仅保证了内容未被篡改，还保证了该哈希确实是由密钥的持有人所生成的。如图所示。</p>
<p><img src="http://qiniu.jzcupid.cn/blog/HMAC%E5%93%88%E5%B8%8C%E4%B8%8E%E6%99%AE%E9%80%9A%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%B7%AE%E5%88%AB.jpg" alt="HMAC哈希与普通哈希算法的差别"></p>
</blockquote>
<p>令牌的第二部分是负载（Payload），这是令牌真正需要向服务端传递的信息。针对认证问题，负载至少应该包含能够告知服务端 “这个用户是谁” 的信息；针对授权问题，令牌至少应该包含能够告知服务端 “这个用户拥有什么角色 / 权限” 的信息。JWT 的负载部分<br>是可以完全自定义的，根据具体要解决的问题不同，设计自己所需要的信息，只是总容量不能太大，毕竟要受到 HTTP Header 大小的限制。一个 JWT 负载的例子如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;icyfenix&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;authorities&quot;</span>: [</span><br><span class="line">  	<span class="string">&quot;ROLE_USER&quot;</span>,</span><br><span class="line">  	<span class="string">&quot;ROLE_ADMIN&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;scope&quot;</span>: [</span><br><span class="line">  	<span class="string">&quot;ALL&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1584948947</span>,</span><br><span class="line">  <span class="attr">&quot;jti&quot;</span>: <span class="string">&quot;9d77586a-3f4f-4cbb-9924-fe2f77dfa33d&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;client_id&quot;</span>: <span class="string">&quot;bookstore frontend&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JWT 在 RFC 7519 中推荐（非强制约束）了七项声明名称（Claim Name），如需要用到<br>这些内容，建议字段名与官方的保持一致。</p>
<ul>
<li>iss（Issuer）:签发人。</li>
<li>exp（Expiration Time）:令牌过期时间。</li>
<li>sub（Subject）:主题。</li>
<li>aud（Audience）:令牌受众。</li>
<li>nbf（Not Before）:令牌生效时间。</li>
<li>iat（Issued At）:令牌签发时间。</li>
<li>jti（JWT ID）:令牌编号。</li>
</ul>
<p>此外在 RFC 8225、RFC 8417、RFC 8485 等规范文档，以及 OpenID 等协议中，都定义了约定好公有含义的名称，内容比较多，这里不再赘述，感兴趣的读者可以参考 “IANA  JSON Web Token Registry。</p>
<p>令牌的第三部分是签名（Signature），签名的意思是：使用在对象头中公开的特定签名算法，通过特定的密钥（由服务器进行保密，不能公开）对前面两部分内容进行加密计算，以例子里使用的 JWT 默认的 HMAC SHA256 算法为例，将通过以下公式产生签名值：<code>HMACSHA256(base64Ur1Encode(header) + &quot;.&quot; + base64UrlEncode (payload), secret)</code> 签名的意义在于确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失任何信息的。因为被签名的内容哪怕发生了一个字节的变动，也会导致整个签名发生显<br>著变化。此外，由于签名这件事情只能由认证授权服务器完成（只有它知道密钥），任何人都无法在篡改后重新计算出合法的签名值，所以服务端才能够完全信任客户端传上来的 JWT 中的负载信息。</p>
<p>JWT 默认的签名算法 HMAC SHA256 是一种带密钥的哈希摘要算法，加密与验证过程均只能由中心化的授权服务来提供，所以这种方式一般只适合于授权服务与应用服务处于同一个进程中的单体应用。在多方系统或者授权服务与资源服务分离的分布式应用中，通<br>常会采用非对称加密算法来进行签名，这时候除了授权服务端持有的可以用于签名的私钥解决，而不在服务层次（譬如在令牌或接口其他参数上增加额外逻辑）上解决。</p>
<ul>
<li><strong>只能携带相当有限的数据</strong>：HTTP 协议并没有强制约束 Header 的最大长度，但是，各种服务器、浏览器都会有自己的约束，譬如Tomcat 就要求 Header 最大不超过 8 KB，而在 Nginx 中则默认为 4 KB，因此在令牌中存储过多的数据不仅耗费传输带宽，还有额外的出错风险。</li>
<li><strong>必须考虑令牌在客户端如何存储</strong>：严谨地说，这个并不是 JWT 的问题而是系统设计的问题。如果授权之后，操作完关掉浏览器就结束了，那把令牌放到内存里面，压根不考虑持久化那是最理想的方案。但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登录的。这样的话，想想客户端该把令牌存放到哪里？Cookie？localStorage？Indexed DB？它们都有泄漏的可能，而令牌一旦泄漏，别人就可以冒充用户的身份做任何事情。</li>
<li><strong>无状态也不总是好的</strong>：这个其实也不是 JWT 的问题。如果不能想象无状态会有什么不好的话，笔者可以提个需求：请基于无状态 JWT的方案，做一个在线用户实时统计功能。</li>
</ul>
<h2 id="四、保密"><a href="#四、保密" class="headerlink" title="四、保密"></a>四、保密</h2><p>保密是加密和解密的统称，是指以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，或者知晓解密的算法但缺少解密所需的必要信息，仍然无法了解数据的真实内容。</p>
<p>按照需要保密的信息所处的环节不同，可以划分为 “信息在客户端时的保密”、“信息在传输时的保密” 和 “信息在服务端时的保密” 三类，或者进一步概括为 “端的保密” 和 “链路的保密” 两类。我们把最复杂、最有效，又早有标准解决方案的 “传输环节” 单独提取出来，放到下一节去讨论，本节将结合笔者的一些个人观点，重点讨论密码等敏感信息如何保障安全等级、是否应该从客户端开始加密、应该如何存储及如何验证等常见的安全保密问题。</p>
<h3 id="1-保密的强度"><a href="#1-保密的强度" class="headerlink" title="1. 保密的强度"></a>1. 保密的强度</h3><p>保密是有成本的，追求越高的安全等级，就要付出越多的工作量与算力消耗。笔者以用户登录为例，列举几种不同强度的保密手段，并讨论它们的防御关注点与弱点。</p>
<ol>
<li>以摘要代替明文：如果密码本身比较复杂，那一次简单的哈希摘要至少可以保证即使传输过程中有信息泄漏，也不会被逆推出原信息；即使密码在一个系统中泄漏了，也不至于威胁到其他系统的使用。但这种处理不能防止弱密码被彩虹表攻击所破解。</li>
<li>先加盐值再做哈希是应对弱密码的常用方法：盐值可以为弱密码建立一道防御屏障，一定程度上防御已有的彩虹表攻击，但不能阻止加密结果被监听、窃取后，攻击者直接发送加密结果给服务端进行冒认。</li>
<li>将盐值变为动态值能有效防止冒认：如果每次密码向服务端传输时都掺入了动态的盐值，让每次加密的结果都不同，那即使传输给服务端的加密结果被窃取了，也不能冒用来进行另一次调用。尽管在双方通信均可能泄漏的前提下协商出只有通信双方才知道的保密信息是完全可行的（后续第五节会提到），但这样协商出盐值的过程将变得极为复杂，而且每次协商只保护一次操作，也难以阻止对其他服务的重放攻击。</li>
<li>给服务加入动态令牌，在网关或其他流量公共位置建立校验逻辑，这样服务端在愿意付出集群中分发令牌信息等代价的前提下，可以做到防止重放攻击，但是依然不能解决传输过程中被嗅探而泄漏信息的问题。</li>
<li>启用 HTTPS 可以防御链路上的恶意嗅探，也以在通信层面解决了重放攻击的问题。但是依然有因客户端被攻破产生伪造根证书的风险、因服务端被攻破产生的证书泄漏而被中间人冒认的风险、因CRL更新不及时或者 OCSP Soft-fail 产生吊销证书被冒用的风险，以及因TLS 的版本过低或密码学套件选用不当产生加密强度不足的风险。</li>
<li>为了抵御上述风险，保密强度还要进一步提升，譬如银行会使用独立于客户端的存储证书的物理设备（俗称的U盾）来避免根证书被客户端中的恶意程序窃取伪造；大型网站涉及账号、金钱等操作时，会使用双重验证开辟一条独立于网络的信息通道（如手机验证码、电子邮件）来显著提高冒认的难度；甚至一些关键企业（如国家电网）或机构（如军事机构）会专门建设遍布全国各地的与公网物理隔离的专用内部网络来保障通信安全。</li>
</ol>
<p>听了上述这些逐步升级的保密措施，你应该能对“更高安全强度同时也意味着更多代价”有更具体的理解，不是任何一个网站、系统、服务都需要无限拔高的安全性。也许这时候你会好奇另一个问题：安全的强度有尽头吗？存不存在某种绝对安全的保密方式？答案可能出乎多数人的意料，确实是有的。信息论之父香农严格证明了一次性密码（One TimePassword）的绝对安全性。但是使用一次性密码必须有个前提，就是已经提前安全地把密码或密码列表传达给对方。譬如，给你的朋友送去一本存储了完全随机密码的密码本，然后每次使用其中一条密码来进行加密通信，用完一条丢弃一条，理论上这样可以做到绝对的安全，但显然这种绝对安全对于互联网没有任何的可行性。</p>
<h3 id="2-客户端加密"><a href="#2-客户端加密" class="headerlink" title="2. 客户端加密"></a>2. 客户端加密</h3><p>关于客户端在用户登录、注册类场景里是否需要对密码进行加密的问题一直存有争议。笔者的观点很明确：为了保证信息不被黑客窃取而做客户端加密没有太大意义，对绝大多数的信息系统来说，启用 HTTPS 可以说是唯一的实际可行的方案。但是，为了保证密码不在服务端被滥用，在客户端就开始加密还是很有意义的。大网站被拖库的事情层出不穷，密码明文被写入数据库、被输出到日志中之类的事情也屡见不鲜，做系统设计时就应该把明文密码这种东西当成是最烫手的山芋来看待，越早消灭掉越好，将一个潜在的炸弹从客户端运到服务端，对绝大多数系统来说都没有必要。</p>
<p>为什么客户端加密对防御泄密没有意义？原因是网络通信并非由发送方和接收方点对点进行的，客户端无法决定用户送出的信息能不能到达服务端，或者会经过怎样的路径到达服务端，在传输链路必定是不安全的假设前提下，无论客户端做什么防御措施，最终都会沦为 “马其诺防线”。之前笔者已经提到多次的中间人攻击，是通过劫持客户端到服务端之间的某个节点，包括但不限于代理（通过HTTP代理返回赝品）、路由器（通过路由导向赝品）、DNS 服务（直接将你机器的 DNS 查询结果替换为赝品地址）等，来给你访问的页面或服务注入恶意的代码，极端情况下，甚至可能会取代你要访问的整个服务或页面，此时不论你在页面上设计了多么精巧严密的加密措施，都不会起到任何保护作用，而攻击者只需劫持路由器，或在局域网内其他机器释放ARP病毒便有可能完成攻击。</p>
<blockquote>
<p><strong>中间人攻击（Man-in-the-Middle Attack，MitM）</strong><br>在消息发出方和接收方之间拦截双方通信。以日常生活中的写信为例：你给朋友写了一封信，邮递员可以把每一份你寄出去的信都拆开看，甚至把信的内容改掉，然后重新封起来，再寄出去给你的朋友。朋友收到信之后给你回信，邮递员又可以拆开看，看完随便改，改完封好再送到你手上。你全程都不知道自己寄出去的信和收到的信都经过邮递员这个 “中间人” 转手和处理——换句话说，对于你和你朋友来讲，邮递员这个“中间人”角色是不可见的。</p>
</blockquote>
<p>对于 “不应把明文传递到服务端” 的观点，也是有一些不同意见的。譬如其中一种保存明文密码的理由是便于客户端做动态加盐，因为只有在服务端存储了明文，或者某种盐值/密钥是固定的加密结果的情况下，才能每次用新的盐值重新加密来与客户端传上来的加密结果进行比对。笔者的建议是每次从服务端请求动态盐值，在客户端加盐传输的做法通常都得不偿失，因为客户端无论是否动态加盐，都不可能代替 HTTPS。真正防御性的密码加密存储确实应该在服务端中进行，但这是为了降低服务端被攻破而批量泄漏密码的风险，并不是为了增加传输过程的安全。</p>
<h3 id="3-密码存储和验证"><a href="#3-密码存储和验证" class="headerlink" title="3. 密码存储和验证"></a>3. 密码存储和验证</h3><p>这节笔者以 Fenix＇s Bookstore 中的真实代码为例，介绍一个普通安全强度的信息系统是如何将密码从客户端传输到服务端，然后存储到数据库的全过程。“普通安全强度” 是指在具有一定保密安全性的基础上，尽量避免消耗过多的运算资源，这样后续验证起来也相对便捷。对多数信息系统来说，只要配合一定的密码规则约束，臂如密码要求长度、特殊字符等，再配合HTTPS传输，已足以抵御大多数风险了。即使用户采用了弱密码、客户端通信被监听、服务端被拖库、泄漏了存储的密文和盐值等问题同时发生，也能够最大限度避免用户明文密码被逆推出来。下面先介绍密码创建的过程。</p>
<ol>
<li><p>用户在客户端注册，输入明文密码：123456。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password ＝<span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>客户端对用户密码进行简单的哈希摘要运算，可选的算法有MD2/4/5、SHA1/256/512、BCrypt、PBKDFI1/2，等等。为了突出“简单”的哈希摘要，这里笔者故意没有排除掉 MD 这类已经有了高效碰撞手段的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client hash <span class="title">MD5</span><span class="params">(password)</span>   <span class="comment">//e10adc3949ba59abbe56e057f20f883e</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>为了防御彩虹表攻击，应加盐处理，客户端加盐只取固定的字符串即可，如实在不安心，也可用伪动态的盐值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client hash <span class="title">MD5</span><span class="params">(MD5(password)</span> ＋ salt)     <span class="comment">//SALT ＝S2as10So5L.dWYEjZjaejOmN3x4Qu</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>假设攻击者截获了客户端发出的信息，得到了摘要结果和采用的盐值，那攻击者就可以枚举遍历所有8位字符以内的弱密码，然后对每个密码再进行加盐计算，就得到一个针对固定盐值的对照彩虹表。为了应对这种暴力破解，并不提倡在盐值上做动态化，更理想的方式是引入慢哈希函数来解决。</p>
<p>慢哈希函数是指执行时间可以调节的哈希函数，通常是以控制调用次数来实现的。BCrypt 算法就是一种典型的慢哈希函数，它做哈希计算时接受盐值 Salt 和执行成本 Cost 两个参数。如果我们将 BCrypt 的执行时间控制在 0.1 秒完成一次哈希计算的话，按照 1 秒生成 10 个哈希值的速度，算完所有的10位大小写字母和数字组成的弱密码大概需要P(62，10) / (3600＊24＊365) / 0.1＝1237204169 年时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client_hash <span class="title">BCrypt</span><span class="params">(MD5(password)</span> + salt)  <span class="comment">//MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>下一步将哈希值传输到服务端，在服务端只需防御被拖库后针对固定盐值的批量彩虹表攻击。具体做法是为每一个密码（指客户端传来的哈希值）产生一个随机的盐值。笔者建议采用 “密码学安全伪随机数生成器”（Cryptographically Secure Pseudo-Random Number Generator，CSPRNG）来生成一个长度与哈希值长度相等的随机字符串。对于Java语言，从 Java SE7 起提供了<code>java.security.SecureRandom</code> 类，用于支持 CSPRNG 字符串生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SecureRandom random new <span class="title">SecureRandom</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">byte</span> server_salt[] <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">36</span>];</span><br><span class="line">random.nextBytes(server_salt);  <span class="comment">//tq2pdxrblkbgp8vt8kbdpmzdh1w8bex</span></span><br></pre></td></tr></table></figure></li>
<li><p>将动态盐值混入客户端传来的哈希值再做一次哈希，产生最终的密文，并和上一步随机生成的盐值一起写入同一条数据库记录中。由于慢哈希算法占用大量处理器资源，笔者并不推荐在服务端中采用。不过，如果你阅读了 Fenix＇s Bookstorel 的源码，会发现这步依然采用了 Spring Security5 中的 <code>BcryptPasswordEncoder</code>，但是请注意它默认构造函数中的 Cost 参数值为 -1，经转换后实际只进行了 1024(2^10) 次计算，并不会给服务端带来太大的压力。此外，代码中并未显式传入 CSPRNG 生成的盐值，这是因为  <code>BCryptPasswordEncoder</code> 本身就会自动调用 CSPRNG 产生盐值，并将该盐值输出在结果的前 32 位之中，因此也无须专门在数据库中设计存储盐值的字段。这个过程以伪代码表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_hash = SHA256(client hash server salt);   <span class="comment">//55b4b5815c216cf80599990e781cd8974a1e384d49fbde7776d096e1dd436f67</span></span><br><span class="line">DB.save(server hash，server_salt);</span><br></pre></td></tr></table></figure>

<p>以上加密存储的过程相对复杂，但是运算压力最大的过程（慢哈希）是在客户端完成的，对服务端压力很小，也不惧怕因网络通信被截获而导致明文密码泄漏。密码存储后，以后验证的过程与加密是类似的，具体步骤如下所示。<br>1）客户端：用户在登录页面中输入密码明文，123456，经过与注册相同的加密过程，向服务端传输加密后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authentication_hash = MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2</span><br></pre></td></tr></table></figure>

<p>2）服务端：接收到客户端传输上来的哈希值，从数据库中取出登录用户对应的密文和盐值，采用相同的哈希算法，对客户端传来的哈希值、服务端存储的盐值计算摘要结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = SHA256(authentication_hash + server_salt);    <span class="comment">//55b4b5815c216cf80599990e781cd8974a1e384d49fbde7776d096e1dd436f67</span></span><br></pre></td></tr></table></figure>

<p>3）比较上一步的结果和数据库储存的哈希值是否相同，如果相同说明密码正确，反之说明密码错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authentication_compare(result, server_hash)     <span class="comment">//yes</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五、传输"><a href="#五、传输" class="headerlink" title="五、传输"></a>五、传输</h2><p>前文中笔者已经为传输安全层挖了不少坑，臂如：基于信道的认证是怎样实现的？为什么HTTPS是绝大部分信息系统防御通信被窃听和篡改的唯一可行手段？传输安全层难道不也是一种自动化的加密吗？为何说无论客户端如何加密都不能代替HTTPS？本节将以 “假设链路上的安全得不到保障，攻击者如何摧毁之前认证、授权、凭证、保密中所提到的种种安全机制” 为场景，讲解传输安全层所要解决的问题，同时也是对前面这些疑问的回答。</p>
<h3 id="1-摘要、加密与签名"><a href="#1-摘要、加密与签名" class="headerlink" title="1. 摘要、加密与签名"></a>1. 摘要、加密与签名</h3><p>我们从 JWT 令牌的一小段 “题外话” 来引出现代密码学算法的三种主要用途：摘要、加密与签名。JWT 令牌携带信息的可信度源自于它是被签过名的信息，是令牌签发者真实意图的体现，因此是不可篡改的。然而，你是否了解签名具体做了什么？为什么有签名就能够让负载中的信息变得不可篡改和不可抵赖呢？要解释数字签名（Digital Signature），必须先从密码学算法的另外两种基础应用 “摘要” 和 “加密” 说起。</p>
<p>摘要也称为数字摘要（Digital Digest）或数字指纹（Digital Fingerprint）。JWT令牌中默认的签名信息是对令牌头、负载和密钥三者通过令牌头中指定的哈希算法（HMACSHA256）计算出来的摘要值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature =  Hash(base64UrlEncode(header) ＋＂.＂＋ base64UrlEncode(payload), secret)</span><br></pre></td></tr></table></figure>

<p>理想的哈希算法都具备两个特性。一是易变性，这是指算法的输入端发生了任何一点细微变动，都会引发雪崩效应（Avalanche Effect），使得输出端的结果产生极大的变化。这个特性常被用来做校验，以保证信息未被篡改，譬如互联网上下载大文件，常会附有一个哈希校验码，以确保下载下来的文件没有因网络或其他原因与原文件产生任何偏差。二是不可逆性，摘要的运算过程是单向的，不可能从摘要的结果中逆向还原出输入值来。世间的信息有无穷多种，而摘要的结果无论其位数是32、128、512位，甚至更多位，都是一个有限的数字，因此输入数据与输出的摘要结果必然不是一一对应的关系。例如，我对一部电影做摘要运算形成 256 位的哈希值，应该没有人会指望从这个哈希值中还原出一部电影。偶尔能听到 MD5、SHA1 或其他哈希算法被破解了的新闻，但这里的 “破解” 并不是 “解密” 的意思，而是指找到了该算法的高效率碰撞方法，能够在合理的时间内生成一个摘要结果为指定内容的输入比特流，但并不能代表这个碰撞产生的比特流就会是原来的输入源。</p>
<p>由这两个特性可见，摘要的意义是在源信息不泄漏的前提下辨别其真伪。易变性保证了可以从公开的特征上甄别出信息是否来自于源信息，不可逆性保证了不会从公开的特征暴露出源信息，这与今天用作身份甄别的指纹、面容和虹膜的生物特征是具有高度可比性的。在一些场合中，摘要也会被借用来做加密（如保密中介绍的慢哈希Berypt算法）和签名（如JWT签名中的HMAC SHA256算法），但在严格意义上看，摘要与这两者有本质的区别。</p>
<p>加密与摘要的本质区别在于加密是可逆的，逆过程就是解密。在经典密码学时代，加密的安全主要依靠机密性来保证，即依靠保护加密算法或算法的热行参数不被泄漏来保障信息的安全。而现代密码学不依靠机密性，加解密算法都是完全公开的，它的安全是建立在特定问题的计算复杂度之上，具体是指算法根据输入端计算输出结果耗费的算力资源很小，但根据输出端的结果反过来推算原本的输入时耗费的算力就极其庞大。以大数的质因数分解为例，我们可以轻而易举地（以O(nlogn) 的复杂度）计算出两个大素数的乘积，<br>臂如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">97667323933</span> * <span class="number">128764321253</span> = <span class="number">12576066674829627448049</span></span><br></pre></td></tr></table></figure>

<p>根据算术基本定理，质因数的分解形式是唯一的，且前面计算条件中给出的运算因子已经是质数、所以 12576066674829627448049 的分解形式就只有唯一的形式，即上面所示的唯一答案。然而如何对大数进行质因数分解，迄今还没有找到多项式时间的算法，甚至无法确切地知道这个问题属于哪个复杂度类（Complexity Class）。所以尽管这个过程在理论上一定是可逆的，但实际上算力差异决定了逆过程无法实现。</p>
<p>根据加密与解密是否采用同一个密钥，可将现代密码学算法分为对称加密算法和非对称加密算法两大类型，这两类算法各有明确的优劣势与应用场景。对称加密算法的缺点显而易见，加密和解密使用相同的密钥，当通信的成员数量增加时，为保证两两通信都采用独立的密钥，密钥数量与成员数量的平方成正比，这必然面临密钥管理的难题。而更尴尬的难题是当通信双方原本不存在安全的信道时，如何将一个只能让通信双方才能知道的密钥传输给对方？如果有通道可以安全地传输密钥，那为何不使用现有的通道传输信息？这个“蛋鸡悖论”曾在很长的时间里严重阻碍了密码学在真实世界的推广应用。</p>
<p>20世纪70年代中后期出现的非对称加密算法从根本上解决了密钥分发的难题，它将密钥分成公钥和私钥。公钥可以完全公开，无须安全传输的保证。私钥由用户自行保管，不参与任何通信传输。根据这两个密钥加解密方式的不同，使得算法可以提供两种不同的功能。</p>
<ul>
<li><strong><font color=red>公钥加密，私钥解密</font>，这种就是加密，用于向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知</strong>。如果甲想给乙发一个安全保密的数据，那么甲乙应该各有一个私钥，甲先用乙的公钥加密这段数据，再用自己的私钥加密这段加密后的数据，最后发给乙，这样确保了内容既不会被读取，也不能被篡改。</li>
<li><strong><font color=red>私钥加密，公钥解密</font>，这种就是签名，用于让所有公钥所有者验证私钥所有者的身份，并且防止私钥所有者发布的内容被篡改</strong>。但是它不用于保证内容不被他人获得。</li>
</ul>
<p>这两种用途在理论上肯定是成立的，在现实中却一般不成立。单靠非对称加密算法，既做不了加密也做不了签名。因为不论是加密还是解密，非对称加密算法的计算复杂度都相当高，其性能比对称加密要差上好几个数量级（不是好几倍）。加解密性能不仅影响速度，还导致现行的非对称加密算法都没有支持分组加密模式。这句话的含义是：由于明文长度与密钥长度在安全上具有相关性，通俗地说，多长的密钥决定了它能加密多长的明文，如果明文太短就需要进行填充，太长就需要进行分组。因非对称加密本身的效率所限，难以支持分组，所以主流的非对称加密算法都只能加密不超过密钥长度的数据，这也决定了非对称加密不能直接用于大量数据的加密。</p>
<p>在加密方面，现在一般会结合对称与非对称加密的优点，以混合加密来保护信道安全，具体做法是用非对称加密来安全地传递少量数据给通信的另一方，再以这些数据为密钥，采用对称加密来安全高效地大量加密传输数据，这种由多种加密算法组合的应用形式称为 “密码学套件”。非对称加密在这个场景中发挥的作用称为 “密钥协商”。</p>
<p>在签名方面，现在一般会结合摘要与非对称加密的优点，以对摘要结果做加密的形式来保证签名的适用性。由于对任何长度的输入源做摘要之后都能得到固定长度的结果，所以只要对摘要的结果进行签名，即相当于对整个输入源进行了背书，保证一旦内容遭到篡改，摘要结果就会变化，签名也就马上失效了。</p>
<p>表5-1汇总了前面提到的三种算法，并列举了它们的主要特征、用途和局限性。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>常见实现</th>
<th>主要用途</th>
<th>主要局限</th>
</tr>
</thead>
<tbody><tr>
<td>哈希摘要</td>
<td>1）不可逆，即不能解密，所以并不是加密算法，只是一些场景把它当作加密算法使用<br/>2）易变性，输入发生1位变动，就可能导致输出结果50％的内容发生改变<br/>3）无论输入长度多少，输出长度固定（2的N次幂）</td>
<td>MD2/4/5/6、SHA0/1/256/512</td>
<td>摘要</td>
<td>无法解密</td>
</tr>
<tr>
<td>对称加密</td>
<td>1）加密和解密是一样的密钥<br/>2）设计难度相对较小，执行速度相对较快<br/>3）加密明文长度不受限制</td>
<td>DES、AES、RC4、IDEA</td>
<td>加密</td>
<td>要解决如何把密钥安全地传递给解密者</td>
</tr>
<tr>
<td>非对称加密</td>
<td>1）加密和解密使用的是不同的密钥<br/>2）明文长度不能超过公钥长度</td>
<td>RSA、BCDSA、ElGamal</td>
<td>签名、传递密钥</td>
<td></td>
</tr>
</tbody></table>
<p>现在，让我们再回到开篇关于 JWT 令牌的几个问题中来。有了哈希摘要、对称和非对称加密算法，JWT 令牌的签名就能保证负载中的信息不可篡改、不可抵赖吗？其实还是不行的，在这个场景里，数字签名的安全性仍存在一个致命的漏洞：公钥虽然是公开的，但在网络世界里“公开”具体是一种什么操作？如何保证每一个获取公钥的服务，拿到的公钥就是授权服务器希望它拿到的？</p>
<p>在网络传输是不可信任的前提下，公钥在网络传输过程中可能已经被篡改，如果获取公钥的网络请求被攻击者截获并篡改，返回了攻击者自己的公钥，那以后攻击者就可以用自己的私钥来签名，让资源服务器无条件信任它的所有行为了。现实世界中可以通过打电话、发邮件、短信息、登报纸、同时发布在多个网站上等很多网络通信之外的途径来公开公钥，但在程序与网络的世界中，就必须找到一种可信任的公开方法，而且这种方法不能依赖加密来实现，否则又将陷入 “蛋鸡” 问题之中。</p>
<h3 id="2-数字证书"><a href="#2-数字证书" class="headerlink" title="2. 数字证书"></a>2. 数字证书</h3><p>当我们无法以“签名”的手段来达成信任时，就只能求助于其他途径。不妨先想一想真实的世界中，我们是如何达成信任的，其实不外乎以下两种。</p>
<ul>
<li><p><strong>基于共同私密信息的信任</strong>。譬如某个陌生号码找你，说是你的老同学，生病了要找你借钱。你能够信任他的方式是向对方询问一些你们两个应该知道，且只有你们两个知道的私密信息，如果对方能够回答出来，他有可能真的是你的老同学，否则他十有八九就是个骗子。</p>
</li>
<li><p><strong>基于权威公证人的信任</strong>。如果有个陌生人找你，说他是警察，让你把存款转到他们的安全账号上。你能够信任他的方式是去一趟公安局，如果公安局担保他确实是个警察，那他有可能真的是警察，否则他十有八九就是个骗子。</p>
</li>
</ul>
<p>回到网络世界中，我们并不能假设授权服务器和资源服务器是互相认识的，所以通常不太会采用第一种方式，而第二种就是目前保证公钥可信分发的标准，即公开密钥基础设施（Public Key Infrastructure，PKI）。</p>
<blockquote>
<p><strong>公开密钥基础设施</strong></p>
<p>又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密钥基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。</p>
<p>在密码学中，公开密钥基础建设借着数字证书认证中心（Certificate Authority，CA）将用户的个人身份跟公开密钥链接在一起，且每个证书中心用户的身份必须是唯一的。链接关系通过注册和发布过程创建，根据担保级别的差异，创建过程可由 CA 的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防抵赖。</p>
</blockquote>
<p>咱们不必纠缠于 PKI 概念上的内容，只要知道里面定义的 “数字证书认证中心” 相当于前面例子中 “权威公证人” 的角色，是负责发放和管理数字证书的权威机构即可。任何人包括你我都可以签发证书，只是不权威罢了。CA 作为受信任的第三方，承担公钥体系中公钥的合法性检验的责任。可是，这里和现实世界仍然有一些区别，在现实世界你去找公安局，其办公大楼不大可能是剧场布景冒认的；而在网络世界，在假设所有网络传输都有可能被截获冒认的前提下，“去CA中心进行认证”本身也是一种网络操作，这与之前的 “去获取公钥” 本质上不是没什么差别吗？其实还是有差别的，世间公钥成千上万不可枚举，而权威的CA中心则应是可数的，“可数”意味着可以不通过网络，而是在浏览器与操作系统出厂时就预置好，或者提前安装好（如银行的证书）。</p>
<p>到这里出现了本节的主角之一：证书（Certificate）。证书是权威 CA 中心对特定公钥信息的一种公证载体，也可以理解为权威 CA 对特定公钥未被篡改的签名背书。由于客户的机器上已经预置了这些权威CA中心本身的证书（称为CA证书或者根证书），所以我们能够在<br>不依靠网络的前提下，使用根证书里面的公钥信息对其所签发的证书中的签名进行确认。到此，终于打破了鸡生蛋、蛋生鸡的循环，使得整套数字签名体系有了坚实的逻辑基础。</p>
<p>PKI 中采用的证书格式是 X.509 标准格式，它定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的，其中最关键的就是认证机构的数字签名和公钥信息两项内容。一个数字证书具体包含以下内容。</p>
<ul>
<li><p><strong>版本号（Version）</strong>：指出该证书使用了哪种版本的 X.509 标准（版本1、版本2或是版本3），版本号会影响证书中的一些特定信息，目前的版本为 3。</p>
<blockquote>
<p>Version:3 （0x2）</p>
</blockquote>
</li>
<li><p><strong>序列号（Serial Number）</strong>：由证书颁发者分配的证书的唯一标识符。</p>
<blockquote>
<p>Seria1 Number: 04:00:00:00:00:01:15:4b:5a:c3:94</p>
</blockquote>
</li>
<li><p><strong>签名算法标识符（Signature Algorithm ID）</strong>：用于签发证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。譬如，SHA1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA1的摘要结果进行加密。</p>
<blockquote>
<p>Signature Algorithm: shalWithRSAEncryption</p>
</blockquote>
</li>
<li><p><strong>认证机构的数字签名（Certificate Signature）</strong>：这是使用证书发布者私钥生成的签名，以确保这个证书在发放之后没有被篡改过。</p>
</li>
<li><p><strong>认证机构（Issuer Name）</strong>：证书颁发者的可识别名。</p>
<blockquote>
<p>Issuer: C＝BE，O＝GlobalSign nv-sa，CN＝GlobalSign Organization Validation CA  -SHA256 - G2</p>
</blockquote>
</li>
<li><p><strong>有效期限（Validity Period）</strong>：证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效。</p>
<blockquote>
<p>Validity</p>
<pre><code>  Not Before :Nov 21 08:00:00 2020 GMT
  Not After   : Nov 22 07:59:59 2021 GMT
</code></pre>
</blockquote>
</li>
<li><p><strong>主题信息（Subject）</strong>：证书持有人唯一的标识符（Distinguished Name），这个名字在整个互联网上应该是唯一的，通常使用的是网站的域名。</p>
<blockquote>
<p>Subject:C＝CN，ST＝GuangDong，L＝Zhuhai，O＝Awosome-Fenix，CN＝＊.icyfenix.cn</p>
</blockquote>
</li>
<li><p><strong>公钥信息（Public-Key）</strong>：包括证书持有人的公钥、算法（指明密钥属于哪种密码系统）的标识符和其他相关的密钥参数。</p>
</li>
</ul>
<h3 id="3-传输安全层"><a href="#3-传输安全层" class="headerlink" title="3. 传输安全层"></a>3. 传输安全层</h3><p>至此，数字签名的安全性已经可以完全自洽了，但相信你大概也已经感受到了这条信任链的复杂与烦琐，如果从确定加密算法、生成密钥、公钥分发、CA认证、核验公钥、签名到验证，每一个步骤都要由最终用户来完成的话，这种意义的 “安全” 估计只能一直是存于实验室中的阳春白雪。如何把这套烦琐的技术体系自动化地应用于无处不在的网络通信之中，便是本节的主题。</p>
<p>在计算机科学里，隔离复杂性的最有效手段（没有之一）就是分层，如果一层不够就再加一层，这点在网络中更是体现得淋漓尽致。OSI 模型、TCP/IP 模型将网络从物理特性（比特流）开始，逐层封装隔离，到了 HTTP 协议这种面向应用的协议里，使用者就已经不会去关心网卡/交换机如何处理数据帧、MAC 地址；不会去关心 ARP 如何做地址转换；不会去关心IP寻址、TCP 传输控制等细节。想要在网络世界中让用户无感知地实现安全通信，最合理的做法就是在传输层之上、应用层之下加入专门的安全层来实现，这样对上层原本基于 HTTP 的 Web 应用来说，影响甚至是无法察觉的。构建传输安全层的这个想法，几乎可以说是和万维网的历史一样长，早在1994年，就已经有公司开始着手去实践了。</p>
<ul>
<li>1994年，网景（Netscape）公司开发了SSL协议（Secure Sockets Layer）的1.0版，这是构建传输安全层的起源，但是SSL1.0从未正式对外发布过。</li>
<li>1995年，Netscape 把 SSL 升级到 2.0 版，正式对外发布，但是刚刚发布不久就被发现有严重漏洞，所以并未大规模使用。</li>
<li>1996年，修补好漏洞的 SSL3.0 对外发布，这个版本得到了广泛应用，很快成为Web网络安全层的事实标准。</li>
<li>1999年，互联网标准化组织接替 Netscape，将 SSL 改名为 TLS（Transport Layer Security）后作为传输安全层的国际标准。第一个正式的版本是 RFC 2246 定义的 TLS1.0，该版 TLS 的生命周期极长，直至笔者写下这段文字的 2020 年 3 月，主流浏览器（Chrome、Firefox、IE、Safari）才刚刚宣布同时停止对 TLS1.0/.1 的支持。而讽刺的是，由于停止后许多政府网站被无法被浏览，此时又正值新冠肺炎疫情（COVID-19）爆发期，Firefox 紧急发布公告宣布撤回该改动，TLS1.0 的生命还在顽强延续。</li>
<li>2006年，TLS 的第一个升级版 1.1 发布（RFC4346），但却沦为被遗忘的孩子，很少人使用，甚至到了 TLS1.1 从来没有已知的协议漏洞被提出的程度。</li>
<li>2008年，在 TLS1.1 发布 2 年之后，TLS1.2 标准发布（RFC5246），迄今超过90％的互联网HTTPS流量是由 TLS1.2 所支持的，现在仍在使用的浏览器几乎都完美支持了该协议。</li>
<li>2018年，最新的 TLS1.3（RFC8446）发布，比起前面版本相对温和的升级，TLS1.3 做出了一些激烈的改动，修改了从 1.0 起一直没有大变化的两轮四次（2-RTT）握手，首次连接仅需一轮（1-RTT）握手即可完成，在连接复用支持时，甚至将 TLS1.2 原本的 1-RTT 下降到 0-RTT，显著提升了访问速度。</li>
</ul>
<p>接下来，笔者以 TLS1.2 为例，介绍传输安全层是如何保障所有信息都是第三方无法窃听（加密传输）、无法篡改（一旦篡改通信<br>算法会立刻发现）、无法冒充（证书验证身份）的。TLS1.2 在传输之前的握手过程一共需要进行上下两轮、共计四次通信，时序图如图</p>
<p><img src="http://qiniu.jzcupid.cn/blog/TLS%E8%BF%9E%E6%8E%A5%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F.png" alt="TLS连接握手时序"></p>
<h4 id="1）客户端请求：Client-Hello"><a href="#1）客户端请求：Client-Hello" class="headerlink" title="1）客户端请求：Client Hello"></a>1）客户端请求：Client Hello</h4><p>客户端向服务器请求进行加密通信，在这个请求里面，它会以 <strong>明文</strong> 的形式，向服务器端提供以下信息。</p>
<ul>
<li>支持的协议版本，如 TLS1.2。但是要注意，1.0 至 3.0 分别代表 SSL1.0 至 3.0，TLS1.0 则是 3.1，一直到 TLS1.3 的 3.4。</li>
<li>一个客户端生成的 32 字节随机数，这个随机数将稍后用于产生加密的密钥。</li>
<li>一个可选的 SessionlD，注意不要和前面的 Cookie-Session 机制混淆了，这个 SessionlD 是指传输安全层的 Session，是为了 TLS 的连接复用而设计的。</li>
<li>一系列支持的密码学算法套件，例如 TLS_RSA_WITH AES128 GCM_SHA256，代表密钥交换算法是 RSA，加密算法是 AES128-GCM，消息认证码算法是 SHA256</li>
<li>一系列支持的数据压缩算法。</li>
<li>其他可扩展的信息，为了保证协议的稳定性，后续对协议的功能扩展大多都添加到这个变长结构中。譬如 TLS1.0 中由于发送的数据并不包含服务器的域名地址，导致一台服务器只能安装一张数字证书，这对虚拟主机来说很不方便，所以 TLS1.1 起就增加了名为 “Server Name” 的扩展信息，以便一台服务器给不同的站点安装不同的证书。</li>
</ul>
<h4 id="2）服务器回应：Server-Hello"><a href="#2）服务器回应：Server-Hello" class="headerlink" title="2）服务器回应：Server Hello"></a>2）服务器回应：Server Hello</h4><p>服务器接收到客户端的通信请求后，如果客户端声明支持的协议版本和加密算法组合与服务端相匹配的话，就向客户端发出回应。如果不匹配，将会返回一个握手失败的警告提示。这次回应同样以明文发送，包括以下信息。</p>
<ul>
<li>服务端确认使用的 TLS 协议版本。</li>
<li>第二个 32 字节的随机数，稍后用于产生加密的密钥。</li>
<li>一个 SessionID，以后可通过连接复用减少一轮握手。</li>
<li>服务端在列表中选定的密码学算法套件。</li>
<li>服务端在列表中选定的数据压缩算法。</li>
<li>其他可扩展的信息。</li>
<li>如果协商出的加密算法组合是依赖证书认证的，服务端还要发送出自己的 X.509 证书，而证书中的公钥是什么，也必须根据协商的加密算法组合来决定。</li>
<li>密钥协商消息，这部分内容对于不同密码学套件有着不同的价值，譬如对于 ECDH + anon 这样的密钥协商算法组合（基于椭圆曲线的 ECDH 算法可以在双方通信都公开的情况下协商出一组只有通信双方知道的密钥）就不需要依赖证书中的公钥，而是通过 Server Key Exchange 消息协商出密钥。</li>
</ul>
<h4 id="3）客户端确认：Client-Handshake-Finished"><a href="#3）客户端确认：Client-Handshake-Finished" class="headerlink" title="3）客户端确认：Client Handshake Finished"></a>3）客户端确认：Client Handshake Finished</h4><p>由于密码学套件的组合复杂多样，这里仅以 RSA 算法为密钥交换算法为例介绍后续过程。</p>
<p>客户端收到服务器应答后，先要验证服务器的证书合法性。如果证书不是可信机构颁布的，或者证书中信息存在问题，譬如域名与实际域名不一致、证书已经过期、通过在线证书状态协议得知证书已被吊销，等等，都会向访问者显示一个 “证书不可信任” 的警告，由用户自行选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥，并向服务器发送以下信息。</p>
<ul>
<li>客户端证书（可选）。部分服务端并不是面向全公众，而是只对特定的客户端提供服务，此时客户端需要发送它自身的证书来证明身份。如果不发送，或者验证不通过，服务端可自行决定是否要继续握手，或者返回一个握手失败的信息。客户端需要证书的 TLS 通信也称为 “双向TLS”（Mutual TLS，常简写为 mTLS）这是云原生基础设施的主要认证方法，也是基于信道认证的最主流形式。</li>
<li>第三个 32 字节的随机数，这个随机数不再是明文发送，而是以服务端传过来的公钥加密，被称为 PreMasterSecret，它将与前两次发送的随机数一起，根据特定算法计算出 48 字节的 MasterSecret，这个 MasterSecretI 即后续内容传输时的对称加密算法所采用的私钥。</li>
<li>编码改变通知、表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的哈希值，以供服务器校验。</li>
</ul>
<h4 id="4）服务端确认：Server-Handshake-Finished"><a href="#4）服务端确认：Server-Handshake-Finished" class="headerlink" title="4）服务端确认：Server Handshake Finished"></a>4）服务端确认：Server Handshake Finished</h4><p>服务端向客户端回应最后的确认通知，包括以下信息。</p>
<ul>
<li><p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
</li>
<li><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的哈希值，以供客户端校验。</p>
</li>
</ul>
<p>至此，整个 TLS 握手阶段宣告完成，一个安全的连接就已成功建立。每一个连接建立时，客户端和服务端均通过上面的握手过程协商出了许多信息，譬如一个只有双方才知道的随机产生的密钥、传输过程中要采用的对称加密算法（例子中的AES128）、压缩算法等，此后该连接的通信将使用此密钥和加密算法进行加密、解密和压缩。这种处理方式对上层协议的功能是完全透明的，虽然在传输性能上会有下降，但在功能上完全不会感知到TS的存在。建立在这层传输安全层之上的 HTTP 协议，被称为 “HTTP over SSL/TLS”，也即大家所熟知的HTTPS。</p>
<p>从上面握手协商的过程中我们还可以得知，HTTPS 并非只有 “启用了HTTPS” 和 “未启用HTTPS” 的差别，采用不同的协议版本、不同的密码学套件，证书是否有效，服务端/客户端面对无效证书时的处理策略等都导致了不同 HTTPS 站点的安全强度的不同，因此并不能说只要启用了 HTTPS 就必能安枕无忧。</p>
<h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>  数据验证与程序如何编码是密切相关的，许多开发者都不会把它归入安全的范畴之中。 但请细想一下，关注 “你是谁”（认证）、“你能做什么”（授权）等问题是很合理的安全，关注 “你做得对不对”（验证）不也同样合理吗？从数量来讲，数据验证不严谨而导致的安全问题比其他安全攻击导致的安全问题要多得多；而从风险上讲，由数据质量导致的问题，风险有高有低，真遇到高风险的数据问题时，面临的损失不一定就比被黑客拖库来得小。相比其他富有挑战性的安全措施，如防御与攻击两者缠斗的精彩，数学、心理、社会工程和计算机等跨学科知识的结合运用，数据验证确实有些无聊、枯燥，这项常规的工作在日常的开发中贯穿于代码的各个层次，每个程序员都肯定写过。但这种常见的代码反而是迫切需要被架构约束的，缺失的校验影响数据质量，过度的校验不会使得系统更加健壮，某种意义上反而会制造垃圾代码，甚至带来副作用。请来看看下面这个实际的段子。</p>
<blockquote>
<p>前端：提交一份用户数据（姓名：某，性别：男，爱好：女，签名：xxx，手机：xxx，邮箱：null）<br>控制器：发现邮箱是空的，抛 ValidationException（＂邮箱没填＂）<br>前端：已修改，重新提交<br>安全：发送验证码时发现手机号少一位，抛 RemoteInvokeException（＂无法发送验证码”）<br>前端：已修改，重新提交<br>服务层：邮箱怎么有重复啊，抛 BusinessRuntimeException（＂不允许开小号＂）<br>前端：已修改，重新提交<br>持久层：签名字段超长了插不进去，抛 SQLException（＂插入数据库失败，SQL:xxx＂）<br>前端：你们这些管挖坑不管埋的后端，各种异常都往前抛！<br>用户：这系统牙膏厂生产的？</p>
</blockquote>
<p>最基础的数据问题可以在前端做表单校验来处理，但服务端验证肯定也是要做的，看完了上面的段子后，那么服务端应该在哪一层做校验呢？可能会有这样的答案。</p>
<ul>
<li>在控制器层做，在服务层不做。理由是从服务开始会有同级重用，出现 <code>ServiceA.foo(params)</code> 调用 <code>ServiceB.bar(params)</code> 时，就会对 params 重复校验两次。</li>
<li>在服务层做，在控制器层不做。理由是无业务含义的格式校验已在前端表单验证处理过，有业务含义的校验，放在控制器层无论如何都不合适。</li>
<li>在控制器层、服务层各做各的。控制器层做格式校验，服务层做业务校验，听起来很合理，但这其实就是上面段子中被嘲笑的行为。</li>
<li>还有其他一些意见，譬如在持久层做校验，理由是持久层是最终入口，把守好写入数据库的质量最重要。</li>
</ul>
<p>上述的讨论大概不会有统一、正确的结论，但是在 Java 里确实有验证的标准做法，笔者提倡的做法是把校验行为从分层中剥离出来，不是在哪一层做，而是在 Bean 上做，即 Java Bean Validation。从 2009 年 JSR 303 的 1.0，到 2013 年 JSR 349 更新的 1.1，到目前最新的 2017 年发布的 JSR 380，均定义了 Bean 验证的全套规范。单独将验证提取、封装，可以获得不少好处：</p>
<ul>
<li><p>对于无业务含义的格式验证，可以做到预置。</p>
</li>
<li><p>对于有业务含义的业务验证，可以做到重用，一个Bean被多个方法用作参数或返回值是很常见的，针对Bean做校验比针对方法做校验更有价值。</p>
</li>
<li><p>利于集中管理，臂如统一认证的异常体系，统一做国际化、统一给客户端的返回格式，等等。</p>
</li>
<li><p>避免对输入数据的防御污染到业务代码，如果你的代码里有很多下面这样的条件判断，就应该考虑重构了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一些已执行的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (someParam ＝<span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeExcetpion(<span class="string">&quot;客官不可以！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利于多个校验器统一执行，统一返回校验结果，避免用户踩地雷、挤牙膏式的试错体验。</p>
</li>
</ul>
<p>据笔者所知，国内的项目使用Bean Validation的并不少见，但多数程序员都只使用到它的内置约束注解（Built-In Constraint）来做一些与业务逻辑无关的通用校验，即下面这堆<br>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＠Null、＠NotNull、＠AssertTrue、＠AssertFalse、＠Min、＠Max、DecimalMin、＠DecimalMax、＠Negative、＠NegativeOrZero、＠Positive、＠PositiveorZeor、＠Szie、＠Digits、＠Pass、＠PastorPresent、＠Future、＠FutureOrPresent、＠Pattern、＠NotEmpty、NotBlank、＠Email</span><br></pre></td></tr></table></figure>

<p>但是与业务相关的校验往往才是最复杂的校验，将简单的校验交给Bean Validation，而把复杂的校验留给自己，这简直是买椟还珠的程序员版本。其实以 Bean Validation 的标准方式来做业务校验才是非常优雅的，以 Fenix＇s Bookstore 在用户资源上的两个方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建新的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@POST</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Response <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@UniqueAccount</span> Account user)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommonResponse.op(() -&gt; service.createAccount(user));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *更新用户信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@PUT</span></span><br><span class="line">  <span class="meta">@CacheEvict(key ＝＂＃user.username＂）</span></span><br><span class="line"><span class="meta">  public Response updateUser(@Valid @AuthenticatedAccount @NotConflictAccount Account user) &#123;</span></span><br><span class="line"><span class="meta">  	return CommonResponse.op(() -&gt; service.updateAccount(user));</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意其中的三个自定义校验注解，它们的含义分别是：</p>
<ul>
<li><code>@UniqueAccount</code>：传人的用户对象必须是唯一的，不与数据库中任何已有用户的名称、手机、邮箱重复。</li>
<li><code>@AuthenticatedAccount</code>：传入的用户对象必须与当前登录的用户一致。</li>
<li><code>＠NotConflictAccount</code>：传人的用户对象中的信息与其他用户是无冲突的，譬如将一 个注册用户的邮箱，修改成与另外一个已存在的注册用户一致的值，这便是冲突。</li>
</ul>
<p>这里的需求很容易理解，注册新用户时，应约束不与任何已有用户的关键信息重复； 而修改自己的信息时，只能与自己的信息重复，而且只能修改当前登录用户的信息。这些约束规则不仅仅为这两个方法服务，还可能在用户资源的其他入口被使用到，甚至在其他分层的代码中被使用到，在Bean上做校验就能一揽子地覆盖上述这些使用场景。下面代码是这三个自定义注解对应校验器的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticatedAccountValidator</span> <span class="keyword">extends</span> <span class="title">Accountvalidationc</span>&lt;<span class="title">AuthenticatedAccount</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> initialize（AuthenticatedAccount constraintAnnotation) &#123;</span><br><span class="line">    predicate = c -&gt; &#123;</span><br><span class="line">      AuthenticAccount loginUser ＝(AuthenticAccount)</span><br><span class="line">        SecurityContextHolder.getContext().getAuthentication()getPrincipal();</span><br><span class="line">      <span class="keyword">return</span> c.getId().equals(loginUser.getId());</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueAccountValidator</span> <span class="keyword">extends</span> <span class="title">AccountValidation</span>＜<span class="title">UniqueAccount</span>＞</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">initialize</span>(<span class="title">UniqueAccount</span> <span class="title">constraintAnnotation</span>）</span>&#123;</span><br><span class="line">    predicate = c -&gt; !repository.existsByUsernameOrEmailOrTelephone</span><br><span class="line">      (c.getUsername(), c.getEmail(), c.getTelephone());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NotConflictAccountValidator</span> <span class="keyword">extends</span> <span class="title">Accountvalidation</span>＜<span class="title">NotConflictAccount</span>＞</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">initialize</span>(<span class="title">NotConflictAccount</span> <span class="title">constraintAnnotation</span>）｛</span></span><br><span class="line"><span class="class">    <span class="title">predicate</span> </span>= c -&gt; &#123;</span><br><span class="line">      Collection&lt;Account&gt; collection repository.findByUsernameOrEmailOrT-elephone(c.getusername(), c.getEmail(), c.getTelephone())；</span><br><span class="line">    <span class="comment">//将用户名、邮件、电话改成与现有信息完全不重复的，或者只与自己重复的，就不算冲突</span></span><br><span class="line">    <span class="keyword">return</span> collection.isEmpty() ||（collection.size() == <span class="number">1</span> &amp;&amp; collection.iterator().next().getId().equals(c.getId()));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样业务校验便和业务逻辑完全分离开来，在需要校验时用 <code>@Valid</code> 注解自动触发，或者通过代码手动触发执行，具体可根据实际项目的要求，将这些注解应用于控制器、服务层、持久层等任何层次的代码之中。此外，对于校验结果不满足时的提示信息，也可以统一处理，如提供默认值、国际化支持（这里没做）、统一的客户端返回格式（创建一个用于 <code>ConstraintViolationException</code> 的异常处理器来实现，代码中有但这里没有贴出来），以及批量执行全部校验，避免给用户带来挤牙膏式的体验。</p>
<p>对于 Bean 与 Bean 校验器，笔者另外有两条编码建议。第一条是对校验项预置好默认的提示信息，这样当校验不通过时用户能获得明确的修正提示，以下是代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 表示一个用户的信息是无冲突的</span></span><br><span class="line"><span class="comment">* “无冲突”是指该用户的敏感信息与其他用户不重合，如将一个注册用户的邮箱，修改成与另外一个已存在的注册用户一致的值，这便是冲突</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME）</span></span><br><span class="line"><span class="meta">@Target(&#123;FIELD, METHOD, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy AccountValidation.NotConflictAccountValidator.class)</span></span><br><span class="line"><span class="meta">public @interface NotConflictAccount &#123;</span></span><br><span class="line"><span class="meta">	String message() default &quot;用户名称、邮箱、手机号码与现存用户产生重复&quot;;</span></span><br><span class="line"><span class="meta">	Class&lt;?[] groups() default &#123;&#125;;</span></span><br><span class="line"><span class="meta">	Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>另外一条建议是将不带业务含义的格式校验注解放到Bcan的类定义之上，将带业务辑的校验放到Bean的类定义的外面。这两者的区别是放在类定义中的注解能够自动运行，而放到类外面的注解需要明确标出才会运行。譬如用户账号实体中的部分代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">extenda</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotEmpty</span>（message = <span class="string">&quot;用户不允许为空&quot;</span>）</span><br><span class="line">  <span class="keyword">private</span> String username</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotEmpty</span>（message = <span class="string">&quot;用户姓名不允许为空&quot;</span>）</span><br><span class="line">  <span class="keyword">private</span> String name；</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String avatar；</span><br><span class="line">  <span class="meta">@Pattern</span>（regexp＝<span class="string">&quot;1\\d&#123;10&#125;&quot;</span>，message = <span class="string">&quot;手机号格式不正确&quot;</span>）</span><br><span class="line">  <span class="keyword">private</span> String telephone；</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Emai1</span>（message = <span class="string">&quot;邮箱格式不正确&quot;</span>）</span><br><span class="line">  <span class="keyword">private</span> String email；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些校验注解都直接放在类定义中，每次执行校验的时候它们都会被运行。由于BaValidation是Java的标准规范，它执行的频率可能比编写代码的程序所预想的更高，如使用Hibernate来做持久化时，便会自动执行Data Object上的校验注解。对于那些不带业务含义的注解，运行是不需要其他外部资源参与的，即不会调用远程服务、访问数据库，这种校验重复执行也不会产生什么成本。</p>
<p>但带业务逻辑的校验，通常就需要外部资源参与执行，这不仅仅是多消耗一点时间和运算资源的问题，由于很难保证依赖的每个服务都是幂等的，重复执行校验很可能会带来额外的副作用。因此应该放到外面让使用者自行判断是否触发。</p>
<p>还有一些 “需要触发一部分校验” 的非典型情况，警如 “新增” 操作 A 时需要执行全部校验规则，“修改”操作B时希望不校验某个字段，“删除” 操作 C 时希望改变某一条校验规则，这时就要启用分组校验来处理，设计一套“新增”“修改”“删除”这样的标识类，置入校验注解的 groups 参数中去实现</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/posts/34144/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Guice 轻量级 DI 框架</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/posts/10722/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Redis 官方可视化工具 RedisInsight</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">JD</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%81"><span class="nav-text">一、认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AE%A4%E8%AF%81%E7%9A%84%E6%A0%87%E5%87%86"><span class="nav-text">1. 认证的标准</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89HTTP-%E8%AE%A4%E8%AF%81"><span class="nav-text">1）HTTP 认证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89Web-%E8%AE%A4%E8%AF%81"><span class="nav-text">2）Web 认证</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%A4%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. 认证的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8E%88%E6%9D%83"><span class="nav-text">二、授权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RBAC"><span class="nav-text">1. RBAC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-OAuth2"><span class="nav-text">2. OAuth2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F"><span class="nav-text">1）授权码模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E9%9A%90%E5%BC%8F%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="nav-text">2）隐式授权模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F"><span class="nav-text">3）密码模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="nav-text">4）客户端模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%87%AD%E8%AF%81"><span class="nav-text">三、凭证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Cookie-Session"><span class="nav-text">1. Cookie-Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JWT"><span class="nav-text">2. JWT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BF%9D%E5%AF%86"><span class="nav-text">四、保密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BF%9D%E5%AF%86%E7%9A%84%E5%BC%BA%E5%BA%A6"><span class="nav-text">1. 保密的强度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A0%E5%AF%86"><span class="nav-text">2. 客户端加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="nav-text">3. 密码存储和验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BC%A0%E8%BE%93"><span class="nav-text">五、传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%91%98%E8%A6%81%E3%80%81%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%AD%BE%E5%90%8D"><span class="nav-text">1. 摘要、加密与签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-text">2. 数字证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%B1%82"><span class="nav-text">3. 传输安全层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%EF%BC%9AClient-Hello"><span class="nav-text">1）客户端请求：Client Hello</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9B%9E%E5%BA%94%EF%BC%9AServer-Hello"><span class="nav-text">2）服务器回应：Server Hello</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A1%AE%E8%AE%A4%EF%BC%9AClient-Handshake-Finished"><span class="nav-text">3）客户端确认：Client Handshake Finished</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A1%AE%E8%AE%A4%EF%BC%9AServer-Handshake-Finished"><span class="nav-text">4）服务端确认：Server Handshake Finished</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%AA%8C%E8%AF%81"><span class="nav-text">六、验证</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
