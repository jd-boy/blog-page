<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="JD">
    
    <title>
        
            ZGC 垃圾收集器 |
        
        Bean You
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jzcupid.cn","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/favicon.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"莫听穿林打叶声，何妨吟啸且徐行。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Bean You
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">ZGC 垃圾收集器</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">JD</span>
                        
                            <span class="author-label">Lv6</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-03-12 17:37:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Java/">Java</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/Java/JVM/">JVM</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/">深入理解JVM虚拟机（第三版）</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>ZGC</strong> (“Z”并非什么专业名词的缩写，这款收集器的名字就叫作ZGarbage Collector)是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器，是由Oracle 公司研发的。</p>
<p>2018年Oracle创建了JEP333将ZGC提交给OpenJDK，推动其进入OpenJDK11的发布清单之中。</p>
<p><strong>ZGC</strong> 和 <strong>Shenandoah</strong> 的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下目，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<p>但是 <strong>ZGC</strong> 和 <strong>Shenandoah</strong> 的实现思路又是差异显著的。</p>
<p>如果说 <strong>RedHat</strong> 公司开发的 <strong>Shenandoah</strong> 像是Oracle的 <strong>G1</strong> 收集器的实际继承者的话，那Oracle 公司开发的 <strong>ZGC</strong> 就更像是Azul System公司独步天下的 <strong>PGC</strong> (Pauseless GC)和 <strong>C4</strong> (Concurrent Continuously Compacting Collector)收集器的同胞兄弟。</p>
<p>早在2005年，运行在AzulVM上的 <strong>PGC</strong> 就已经实现了标记和整理阶段都全程与用户线程并发运行的垃圾收集，而运行在ZingVM上的C4收集器是PGC继续演进的产物，主要增加了分代收集支持，大幅提升了收集器能够承受的对象分配速度。</p>
<p>无论从算法还是实现原理上来讲，<strong>PGC <strong>和 <strong>C4</strong> 肯定算是一脉相承的，而ZGC虽然并非Azul公司的产品，但也应视为这条脉络上的另一个节点，因为 <strong>ZGC</strong> 几乎所有的关键技术上，与</strong>PGC</strong>和<strong>C4</strong>都只存在术语称谓上的差别，实质内容几乎是一模一样的。</p>
<p>相信到这里读者应该已经对 <strong>Java</strong> 虚拟机收集器常见的专业术语都有所了解了，如果不避讳专业术语的话，我们可以给<strong>ZGC</strong>下一个这样的定义来概括它的主要特征：</p>
<p><strong>ZGC 收集器是一款基于 Region 内存布局的，(暂时)不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的 标记-整理 算法的，以低延迟为首要目标的一款垃圾收集器。</strong></p>
<h2 id="二、ZGC-内存布局"><a href="#二、ZGC-内存布局" class="headerlink" title="二、ZGC 内存布局"></a>二、ZGC 内存布局</h2><p>与 <strong>Shenandoah</strong> 和 <strong>G1</strong> 一样，<strong>ZGC</strong> 也采用基于 <strong>Region</strong> 的堆内存布局，但与它们不同的是，</p>
<p><strong>ZGC 的 Region （在一些官方资料中将它称为 Page 或者 ZPage，本章为行文一致继续称为 Region）具有动态性——动态创建和销毁，以及动态的区域容量大小。</strong></p>
<p>在x64硬件平台下，<strong>ZGC</strong> 的 <strong>Region</strong> 可以具有如图3-19所示的大、中、小三类容量：</p>
<ul>
<li><strong>小型 Region（Small Region）</strong>：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li><strong>中型 Region（Medium Region）</strong>：容量固定为32MB，用于放置大于等于256KB 但小于4MB的对象。</li>
<li><strong>大型Region（Large Region）</strong>：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型 <strong>Region</strong> 中只会存放一个大对象，这也预示着虽然名字叫作”大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。</li>
</ul>
<p><img src="../../../imgs/JVM/jvm7.png" alt="ZGC内存布局"></p>
<h3 id="三、染色指针"><a href="#三、染色指针" class="headerlink" title="三、染色指针"></a>三、染色指针</h3><p><strong>Shenandoah</strong> 使用 <strong>转发指针</strong> 和 <strong>读屏障</strong> 来实现并发整理，<strong>ZGC</strong> 虽然同样用到了 <strong>读屏障</strong>，但用的却是一条与 <strong>Shenandoah</strong> 完全不同，更加复杂精巧的解题思路。</p>
<p><strong>ZGC</strong> 收集器有一个标志性的设计是它采用的 <strong>染色指针</strong> 技术（Colored Pointer，其他类似的技术中可能将它称为Tag Pointer或者Version Pointer）。</p>
<h4 id="（1）为什么需要染色指针？"><a href="#（1）为什么需要染色指针？" class="headerlink" title="（1）为什么需要染色指针？"></a>（1）为什么需要染色指针？</h4><p>从前，如果我们要在对象上存储一些额外的、只供收集器或者虚拟机本身使用的数据，通常会在对象头中增加额外的存储字段，如对象的哈希码、分代年龄、锁记录等就是这样存储的。</p>
<p>这种记录方式在有对象访问的场景下是很自然流畅的，不会有什么额外负担。但如果对象存在被移动过的可能性，即不能保证对象访问能够成功呢？又或者有一些根本就不会去访问对象，但又希望得知该对象的某些信息的应用场景呢？</p>
<p>能不能从指针或者与对象内存无关的地方得到这些信息，譬如是否能够看出来对象被移动过？</p>
<p>这样的要求并非不合理的刁难，先不去说并发移动对象可能带来的可访问性问题，此前我们就遇到过这样的要求——<strong>追踪式收集算法</strong> 的标记阶段就可能存在只跟指针打交道而不必涉及指针所引用的对象本身的场景。</p>
<p>例如对象标记的过程中需要给对象打上三色标记，这些标记本质上就只和对象的引用有关，而与对象本身无关——某个对象只有它的引用关系能决定它存活与否，对象上其他所有的属性都不能够影响它的存活判定结果。</p>
<p><strong>HotSpot</strong> 虚拟机的几种收集器有不同的标记实现方案。</p>
<p>有的把标记直接记录在对象头上(如Serial收集器)，有的把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah 使用了一种相当于堆内存的1/64大小的、称为BitMap的结构来记录标记信息）。</p>
<p>而 <strong>ZGC 的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象图来标记对象、还不如说是遍历“引用图”来标记“引用”了</strong>。</p>
<h4 id="（2）为什么指针本身也可以存储额外信息？"><a href="#（2）为什么指针本身也可以存储额外信息？" class="headerlink" title="（2）为什么指针本身也可以存储额外信息？"></a>（2）为什么指针本身也可以存储额外信息？</h4><p><strong>染色指针是一种直接将少量额外的信息存储在指针上的技术</strong>，可是为什么指针本身也可以存储额外信息呢？</p>
<p>在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节。</p>
<p>实际上，基于需求（用不到那么多内存）、性能（地址越宽在做地址转换时需要的页表级数越多）和成本（消耗更多晶体管）的考虑，在AMD64架构中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。</p>
<p>此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。</p>
<p>尽管 Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的 64TB内存在今天仍然能够充分满足大型服务器的需要。</p>
<p>鉴于此，<strong>ZGC</strong> 的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。</p>
<p><strong>通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移过）、是否只能通过finalize()方法才能被访问到。</strong></p>
<p><img src="../../../imgs/JVM/jvm8.png" alt="染色指针示意"></p>
<p><strong>由于这些标志进一步压缩了原本就只有46位的地址空间，也直接导致 ZGC 能够管理的内存不可以超过4TB（2的42次幂）。</strong></p>
<p>虽然 <strong>染色指针有4TB的内存限制，不能支持32位平台，不能支持压缩指针（-XX:+UseCompressedOops）等诸多约束，但它带来的收益也是非常可观的。</strong></p>
<h4 id="（3）染色指针三大优势"><a href="#（3）染色指针三大优势" class="headerlink" title="（3）染色指针三大优势"></a>（3）染色指针三大优势</h4><ul>
<li>染色指针可以使得一旦某个 <strong>Region</strong> 的存活对象被移走之后，这个 <strong>Region</strong> 立即就能够被释放和重用掉，而不必等待整个堆中所有指向该 <strong>Region</strong> 的引用都被修正后才能清理。这点相比起 <strong>Shenandoah</strong> 是一个颇大的优势，使得理论上只要还有一个空闲 <strong>Region</strong>，<strong>ZGC</strong> 就能完成收集，而 <strong>Shenandoah</strong> 需要等到引用更新阶段结束以后才能释放回收集中的 <strong>Region</strong>，这意味着堆中几乎所有对象都存活的极端情况，需要1:1复制对象到新 <strong>Region</strong> 的话，就必须要有一半的空闲 <strong>Region</strong> 来完成收集。至于为什么染色指针能够导致这样的结果，笔者将在后续解释其“自愈”特性的时候进行解释。</li>
<li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。实际上，到目前为止 <strong>ZGC</strong> 都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。内存屏障对程序运行时性能的损耗在前面章节中已经讲解过，能够省去一部分的内存屏障，显然对程序运行效率是大有裨益的，所以 <strong>ZGC</strong> 对吞吐量的影响也相对较低。</li>
<li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。现在Linux下的64位指针还有前18位并未使用，它们虽然不能用来寻址，却可以通过其他手段用于信息记录。如果开发了这18位，既可以腾出已用的4个标志位，将 ZGC 可支持的最大堆内存从4TB 拓展到64TB，也可以利用其余位置再存储更多的标志，譬如存储一些追踪信息来让垃圾收集器在移动对象时能将低频次使用的对象移动到不常访问的内存区域。</li>
</ul>
<p>不过要顺利应用染色指针有一个必须解决的前置问题：</p>
<p>Java 虚拟机作为一个普普通通的进程，这样随意重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？</p>
<p>这是很现实的问题，无论中间过程如何，程序代码最终都要转换为机器指令流交付给处理器去执行，处理器可不会管指令流中的指针哪部分存的是标志位，哪部分才是真正的寻址地址，只会把整个指针都视作一个内存地址来对待。</p>
<p>这个问题在 Solaris/SPARC 平台上比较容易解决，因为 SPARC 硬件层面本身就支持虚拟地址掩码，设置之后其机器指令直接就可以忽略掉染色指针中的标志位。</p>
<p>但在x86-64平台上并没有提供类似的黑科技 <strong>ZGC</strong> 设计者就只能采取其他的补救措施了，这里面的解决方案要涉及虚拟内存映射技术，让我们先来复习一下这个x86计算机体系中的经典设计。</p>
<h4 id="（4）虚拟内存映射技术"><a href="#（4）虚拟内存映射技术" class="headerlink" title="（4）虚拟内存映射技术"></a>（4）虚拟内存映射技术</h4><p>在远古时代的 x86 计算机系统中，所有进程都是共用同一块物理内存空间的，这样会导致不同进程之间的内存无法相互隔离，当一个进程污染了别的进程内存后，就只能对整个系统进行复位后才能得以恢复。</p>
<p>为了解决这个问题，从 Intel 80386 处理器开始，提供了 “保护模式” 用于隔离进程， 386 处理器的全部 32 条地址寻址线都有效，进程可访问最高内存也可达 4 GB 的内存空间，但此时已不同于之前实模式下的物理内存寻址了。</p>
<p>处理器会使用分页管理机制把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为“页”（Page）。</p>
<p>通过在线性虚拟空间的页与物理地址空间的页之间建立的映射表，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p>
<p>如果读者对计算机结构体系了解不多的话，不妨设想这样一个场景来类比：假如你要去“中山一路3号”这个地址拜访一位朋友，根据你所处城市的不同，譬如在广州或者在上海，是能够通过这个“相同的地址”定位到两个完全独立的物理位置的，这时地址与物理位置是一对多关系映射。</p>
<p>不同层次的虚拟内存到物理内存的转换关系可以在硬件层面、操作系统层面或者软件进程层面实现，如何完成地址转换，是一对一、多对一还是一对多的映射，也可以根据实际需要来设计。</p>
<p>Linux/x86-64平台上的 <strong>ZGC</strong> 使用了 <strong>多重映射（Multi-Mapping）</strong>将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着 <strong>ZGC</strong> 在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。</p>
<p>把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p>
<p><img src="../../../imgs/JVM/jvm9.png" alt="多重映射下的寻址"></p>
<p>在某些场景下，多重映射技术确实可能会带来一些诸如复制大对象时会更容易这样的额外好处，可从根源上讲，<strong>ZGC</strong> 的多重映射只是它采用染色指针技术的伴生产物，并不是专门为了实现其他某种特性需求而去做的。</p>
<h2 id="四、ZGC-收集过程"><a href="#四、ZGC-收集过程" class="headerlink" title="四、ZGC 收集过程"></a>四、ZGC 收集过程</h2><p><strong>ZGC</strong> 的运作过程大致可划分为以下四个大的阶段。</p>
<p>全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段，这些小阶段，譬如初始化 <strong>GCRoot</strong> 直接关联对象的 <strong>MarkStart</strong>，与之前 <strong>G1</strong> 和 <strong>Shenandoah</strong> 的 <strong>Initial Mark</strong> 阶段并没有什么差异。</p>
<p><img src="../../../imgs/JVM/jvm10.png" alt="ZGC运作过程"></p>
<ul>
<li><strong>并发标记（Concurrent Mark）</strong>：与 <strong>G1</strong>、<strong>Shenandoah</strong> 一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于<strong>G1</strong>、<strong>Shenandoah</strong> 的初始标记、最终标记（尽管 <strong>ZGC</strong> 中的名字不叫这些）的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与 <strong>G1</strong>、<strong>Shenandoah</strong> 不同的是，<strong>ZGC</strong> 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的 <strong>Marked0</strong>、<strong>Marked1</strong> 标志位。</li>
<li><strong>并发预备重分配（Concurrent Prepare for Relocate）</strong>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些 <strong>Region</strong>，将这些 <strong>Region</strong> 组成重分配集（Relocation Set）。重分配集与 <strong>G1</strong> 收集器的回收集（Collection Set）还是有区别的 <strong>ZGC</strong> 划分 <strong>Region</strong> 的目的并非为了像 <strong>G1</strong> 那样做收益优先的增量回收。相反，<strong>ZGC 每次回收都会扫描所有的 Region，用范围更大的扫描成本换取省去 G1 中记忆集的维护成本</strong>。因此，<strong>ZGC</strong> 的重分配集只是决定了里面的存活对象会被重新复制到其他的 <strong>Region</strong> 中，里面的 <strong>Region</strong> 会被释放，而并不能说回收行为就只是针对这个集合里面的 <strong>Region</strong> 进行，因为标记过程是针对全堆的。此外，在JDK 12 的 <strong>ZGC</strong> 中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li>
<li><strong>并发重分配（Concurrent Relocate）</strong>：重分配是 <strong>ZGC</strong> 执行过程中的核心阶段，<strong>这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的每个 Region 维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。</strong>得益于染色指针的支持，<strong>ZGC</strong> 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据 <strong>Region</strong> 上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，<strong>ZGC</strong> 将这种行为称为指针的 “自愈” （Self-Healing）能力。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次，对比 <strong>Shenandoah</strong> 的 <strong>Brooks</strong> 转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢，因此 <strong>ZGC</strong> 对用户程序的运行时负载要比 <strong>Shenandoah</strong> 来得更低一些。还有另外一个直接的好处是由于染色指针的存在，一旦重分配集中某个 <strong>Region</strong> 的存活对象都复制完毕后，这个 <strong>Region</strong> 就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。 </li>
<li><strong>并发重映射（Concurrent Remap）</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与 <strong>Shenandoah</strong> 并发引用更新阶段一样的，但是 <strong>ZGC</strong> 的并发重映射并不是一个必须要 “迫切” 去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很 “迫切”。因此，<strong>ZGC</strong> 很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。</li>
</ul>
<p><strong>ZGC</strong> 的设计理念与AzulSystem公司的 <strong>PGC</strong> 和 <strong>C4</strong> 收集器一脉相承，是迄今垃圾收集器研究的最前沿成果，它与 <strong>Shenandoah</strong> 一样做到了几乎整个收集过程都全程可并发，短暂停顿也只与 <strong>GC Roots</strong> 大小相关而与堆内存大小无关，因而同样实现了任何堆上停顿都小于十毫秒的目标。</p>
<p>相比 <strong>G1</strong>、<strong>Shenandoah</strong> 等先进的垃圾收集器，<strong>ZGC</strong> 在实现细节上做了一些不同的权衡选择。</p>
<p>譬如 <strong>G1</strong> 需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现 <strong>Region</strong> 的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。</p>
<p>ZGC就完全没有使用记忆集，它甚至连分代都没有，连像 <strong>CMS</strong> 中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多。</p>
<p>可是，必定要有优有劣才会称作权衡。</p>
<h4 id="ZGC-劣势"><a href="#ZGC-劣势" class="headerlink" title="ZGC 劣势"></a>ZGC 劣势</h4><p><strong>ZGC 的这种选择也限制了它能承受的对象分配速率不会太高</strong>，可以想象以下场景来理解 <strong>ZGC</strong> 的这个劣势：</p>
<p><strong>ZGC</strong> 准备要对一个很大的堆做一次完整的并发收集，假设其全过程要持续十分钟以上（请读者切勿混淆并发时间与停顿时间，<strong>ZGC</strong> 立的Flag是停顿时间不超过十毫秒），在这段时间里面，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部当作存活对象来看待——尽管其中绝大部分对象都是朝生夕灭的，这就产生了大量的浮动垃圾。</p>
<p>如果这种高速分配持续维持的话，每一次完整的并发收集周期都会很长，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间堆中剩余可腾挪的空间就越来越小了。</p>
<p>目前唯一的办法就是尽可能地增加堆容量大小，获得更多喘息的时间。但是若要从根本上提升 <strong>ZGC</strong> 能够应对的对象分配速率，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<p>Azul的 <strong>C4</strong> 收集器实现了分代收集后，能够应对的对象分配速率就比不分代的 <strong>PGC</strong> 收集器提升了十倍之多。</p>
<h4 id="ZGC-优点"><a href="#ZGC-优点" class="headerlink" title="ZGC 优点"></a>ZGC 优点</h4><p><strong>ZGC</strong> 还有一个常在技术资料上被提及的优点是支持 “NUMA-Aware” 的内存分配。</p>
<p><strong>NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构。</strong></p>
<p>由于摩尔定律逐渐失效，现代处理器因频率发展受限转而向多核方向发展，以前原本在北桥芯片中的内存控制器也被集成到了处理器内核中，这样每个处理器核心所在的裸晶（DIE）都有属于自己内存管理器所管理的内存，如果要访问被其他外理器核心管理的内存，就必须通过 Inter-Connect 通道来完成，这要比访问处理器的本地内存慢得多。</p>
<p>在 <strong>NUMA</strong> 架构下，<strong>ZGC</strong> 收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p>
<p>在 <strong>ZGC</strong> 之前的收集器就只有针对吞吐量设计的 <strong>Parallel Scavenge</strong> 支持 <strong>NUMA</strong> 内存分配，如今 <strong>ZGC</strong> 也成为另外一个选择。</p>
<p>在性能方面，尽管目前还处于实验状态，还没有完成所有特性，稳定性打磨和性能调优也仍在进行，但即使是这种状态下的 <strong>ZGC</strong>，其性能表现已经相当亮眼，从官方给出的测试结果来看，用 “令人震惊的、革命性的 ZGC” 来形容都不为过。</p>
<p>图3-23 和图3-24是 <strong>ZGC</strong> 与 <strong>Parallel Scavenge</strong> 、<strong>G1</strong> 三款收集器通过 SPECjbb 2015的测试结果。</p>
<p>在 <strong>ZGC</strong> 的 “弱项” 吞吐量方面，以低延迟为首要目标的 <strong>ZGC</strong> 已经达到了以高吞吐量为目标 <strong>Parallel Scavenge</strong> 的 99%，直接超越了<strong>G1</strong>。如果将吞吐量测试设定为面向 SLA（Service Level Agreements）应用的 “Critical Throughput” 的话，<strong>ZGC</strong> 的表现甚至还反超了 <strong>Parallel Scavenge</strong> 收集器。<br>而在 <strong>ZGC</strong> 的强项停顿时间测试上，它就毫不留情地与 <strong>Parallel Scavenge</strong>、<strong>G1</strong> 拉开了两个数量级的差距。不论是平均停顿，还是95%停顿、99%停顿、99.9%停顿，抑或是最大停顿时间，<strong>ZGC</strong> 均能毫不费劲地控制在十毫秒之内，以至于把它和另外两款停顿数百近千毫秒的收集器放到一起对比，就几乎显示不了 <strong>ZGC</strong> 的柱状条(图3-24a)，必须把结果的纵坐标从线性尺度调整成对数尺度（图 3-24b，纵坐标轴的尺度是对数增长的）才能观察到 <strong>ZGC</strong> 的测试结果。</p>
<p><img src="../../../imgs/JVM/jvm11.png" alt="ZGC测试"></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/posts/63375/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">G1 垃圾收集器</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/posts/64877/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Prometheus Operator 监控 K8S应用</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">JD</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="nav-text">一、介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ZGC-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">二、ZGC 内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88"><span class="nav-text">三、染色指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-text">（1）为什么需要染色指针？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%87%E9%92%88%E6%9C%AC%E8%BA%AB%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="nav-text">（2）为什么指针本身也可以存储额外信息？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88%E4%B8%89%E5%A4%A7%E4%BC%98%E5%8A%BF"><span class="nav-text">（3）染色指针三大优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF"><span class="nav-text">（4）虚拟内存映射技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81ZGC-%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B"><span class="nav-text">四、ZGC 收集过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZGC-%E5%8A%A3%E5%8A%BF"><span class="nav-text">ZGC 劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZGC-%E4%BC%98%E7%82%B9"><span class="nav-text">ZGC 优点</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
